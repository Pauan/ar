#! /usr/bin/env arc

(import ;boyer-moore
        nuit/nuit-parse
        parse-script-args
        strings ; Only needed for urlencode-path
        sxml)

(parameter playlists  nil)
(parameter folders    nil)

(= version      "2.0"
   options      (obj)

   patterns     nil
   errors       nil
   files        (obj)

   filetypes    '(flac flv mid mkv mp3 mp4 ogg ogm wav webm wma)

   script-args  (w/parse-args script-args
                  ("-v" "--version" ()
                    "Displays the version number and exits"
                    (prn version)
                    (quit))
                  ("-d" "--debug" ()
                    "Prints additional messages"
                    (= debug? t))
                  #|("-i" "--info" (t)
                    "Displays information about a template; doesn't write any files"
                    (= options!info t))|#
                  ))
                  ;((in)  "Folder where you keep your templates")
                  ;((out) "Folder where the .xspf files are written to")

(def dirall-ext (exts)
  (dirall nil (fn (x)
                (and (no:hidden-file? x)
                         ; TODO use dirname ?
                     (or (dir-exists x)
                         (some (sym:downcase:extension x) exts))))))

#|
; TODO should probably be in strings.arc or utils.arc
(def rtokens (str test)
  (awith (s    (coerce str 'cons)
          acc  (list nil))
    (if (no s)
          (map string:rev acc)
        (caris s test)
          (self cdr.s (cons nil acc))
        (self cdr.s (cons (cons car.s car.acc) cdr.acc)))))

(def split-path (x)
  (rtokens x #\/))

(def join-path (x)
  (string:intersperse #\/ rev.x))|#

(def process-pattern (x)
  ;(boyer-moore-process x)
  (regexp (%.regexp-quote x)))

(def process-folder (x)
  (regexp:string "(?:^|/)"
                 (%.regexp-quote x)
                             ; TODO use last
                 (unless (is (x:- len.x 1) #\/) "/")))

(def normalize-file (k v)
  (w/playlists (cons k playlists)
    (awhenlet (x . rest) v
      (if acons.x
          (case car.x
            "title"    (= playlists (cons cadr.x cdr.playlists))
            "include"  (push (list* 'include (list car.playlists) cdr.x)
                             patterns)
            "playlist" (w/playlists (cons cadr.x playlists)
                         (self cddr.x))
            "folder"   (w/folders (cons (process-folder cadr.x) folders) ;(split-path )
                         (self cddr.x)))
          (push (list x process-pattern.x folders rev.playlists) ;(map process-pattern split-path.x)
                patterns))
      (self rest))))

#|(def path-match (x y)
  ;(prn car.x)
  ;(prn car.y)
  ;(prn)
  (if (no x)
        t
      (no y)
        nil
      (and (%.regexp-match? car.x car.y)
           (path-match cdr.x cdr.y))))

(def folder-match (x y)
  ;(prn x)
  ;(prn y)
  ;(prn)
  (if (no x)
        t
      (no y)
        nil
      (or (and (is car.x car.y)
               (folder-match cdr.x cdr.y))
          (folder-match x cdr.y))))|#

; (posmatch "foo" "fobarfo")
#|(def posmatch (pat in)
  (with (orig  (coerce pat 'cons)
         in    (coerce in 'cons))
    (awith (pat   orig
            in    in
            jump  in
            i     0)
      (if (no pat)
            i
          (no in)
            nil
          (or (and (is   car.pat car.in)
                   (self cdr.pat cdr.in jump i))
              (self orig cdr.jump cdr.jump (+ i 1)))))))|#


; 19502   boyer-moore-search
; 56148   my posmatch
; 118529  strings.arc posmatch
; 7214    re-match
; 1995    %.regexp-match?

; http://en.wikipedia.org/wiki/Injective_function
(def process-injective (patterns inputs)
  (debug "processing " len.patterns " patterns with " len.inputs " inputs")
  (let seen (obj)
    (maplet x patterns
      (if (isa car.x 'sym)
          x
          (let (pat proc folders playlists) x
            (withs (f  (trues (fn (file)
                                (and (%.regexp-match? proc file)
                                     ;(path-match proc file)
                                     (all [or (%.regexp-match? _ file) nil] folders)
                                     file) ;folder-match
                                  ;(join-path file)
                                  )
                              inputs)
                    c  car.f)
              (aif no.f
                     (push (list "no-file" (list pat playlists))
                           errors)
                   cdr.f
                     (push (list "multi-file" (list pat playlists) f)
                           errors)
                   seen.c
                     (push (list "multi-pattern" (list pat playlists) list.c it)
                           errors))
              (each c f
                (= seen.c (list pat playlists)))
              (list c playlists)))))))

(def print-patterns args
  (prn "  @patterns")
  (each x (map car args)
    (prn "    " x)))

(def print-files (x)
  (prn "  @files")
  (each x x
    (prn "    " x)))

(def print-playlists args
  (prn "  @playlists")
  (each x (dedup:apply join (map cadr args))
    (prn "    " x)))

(let processed (obj)
  (def process-file (name)
    (or= processed.name
         (mappend (fn (x)
                    (if (caris x 'include)
                        (mappend process-file cdr.x)
                        x))
                  files.name))))

(def encode-path (s)
                    ;; TODO: relies on Nu specific changes to lib/strings.arc
  (string "file://" (urlencode-path:string cwd s)))

(def ->sxml (title files)
  (w/pretty:->xml
    `(playlist version  "1"
               xmlns    "http://xspf.org/ns/0/"
               xml:base ,cwd
       (title ,title)
       (trackList ,@(maplet x files
                      `(track (location ,encode-path.x)))))))

;=============================================================================
;  Input and processing
;=============================================================================
(let input car.script-args
  (zap todir input)
  (w/cwd input
    (each name (dir ".")
      (if (hidden-file? name)
          (debug "ignoring hidden file \"" input name "\"")
          (let value (w/infile s name nuit-parse.s)
            (normalize-file name value))))))

(let time (msec)
  (zap process-injective patterns dirall-ext.filetypes) ;(map split-path )
  (debug "took " (- (msec) time) " msec to process all patterns"))

;=============================================================================
;  Errors
;=============================================================================
(each (n x file other) errors
  (prn)
  (pr "@error ")
  (case n
    "no-file"
      (do (prn "pattern did not match any file")
          (print-patterns x)
          (print-playlists x))
    "multi-file"
      (do (prn "pattern matched multiple files")
          (print-patterns x)
          (print-files file)
          (print-playlists x))
    "multi-pattern"
      (do (prn "file was matched by multiple patterns")
          (print-files file)
          (print-patterns x other)
          (print-playlists x other))
    (err "invalid error message" n rest)))

(when errors
  (prn)
  (prn "aborting due to errors")
  (quit 1))

;=============================================================================
;  Output
;=============================================================================
(each (file playlists . rest) patterns
  (each x playlists
    (push (cons file rest) files.x)))

(let output cadr.script-args
  (zap todir output)
  (each (k v) files
    (iflet v process-file.k
      (let v (->sxml k v)
        (w/cwd output
          (debug "writing to \"" output k ".xspf\"")
          (w/outfile out (+ k ".xspf")
            (disp v out))))
      (debug "ignoring playlist \"" k "\" because it is empty"))))
