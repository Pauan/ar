(import nuit/parse
        parse-script-args
        strings ; Only needed for urlencode-path
        sxml)

(var playlists  nil)
(var folders    nil)

(var version      "3.0"
     options      (hash)

     strings      nil
     errors       nil
     files        (hash)

     filetypes    (list "flac" "flv" "mid" "mkv"  "mp3" "mp4"
                        "ogg"  "ogm" "wav" "webm" "wma")

     script-args  (w/parse-args script-args
                    ("-v" "--version" ()
                      "Displays the version number and exits"
                      (prn version)
                      (quit))
                    #|("-d" "--debug" ()
                      "Prints additional messages"
                      (= debug? t))|#
                    ))
                    ;((in)  "Folder where you keep your templates")
                    ;((out) "Folder where the .xspf files are written to")

(def dirall-ext (exts)
  (sort < (dirall nil (fn (x)
            (and (no:hidden-file? x)
                     ; TODO use dirname ?
                 (or (dir-exists x)
                     (some (sym:downcase:extension x) exts)))))))

(def process-string (x)
  (->re (re-escape x)))

(def process-folder (x)
  (->re:string "(?:^|/)"
               (re-escape x)
                           ; TODO use last
               (unless (is (x:- len.x 1) #\/) "/")))

(def insert-file (x)
  (push (list x process-string.x folders rev.playlists)
        strings))

(def normalize-file (k v)
  (w/ playlists (cons k playlists)
    (awhenlet (x . rest) v
      (if acons.x
          (case car.x
            "title"    (= playlists (cons cadr.x cdr.playlists))
            "include"  (push (list* 'include (list car.playlists) cdr.x)
                             strings)
            "playlist" (w/ playlists (cons cadr.x playlists)
                         (self cddr.x))
            "folder"   (w/ folders (cons (process-folder cadr.x) folders)
                         (self cddr.x))
            "file"     (if (assoc "ignore" cddr.x)
                           (prn "ignoring file " cadr.x)
                           (insert-file cadr.x)))
          (insert-file x))
      (self rest))))

; http://en.wikipedia.org/wiki/Injective_function
(def process-injective (strings files)
  (debug "processing " len.strings " strings and " len.files " files")
  (let seen (obj)
    (maplet x strings
      (if (isa car.x 'sym)
          x
          (let (pat proc folders playlists) x
            (withs (f  (trues (fn (file)
                                (and (re? proc file)
                                     (all [or (re? _ file) nil] folders)
                                     file))
                              files)
                    c  car.f)
              (aif no.f
                     (push (list "no-file" (list pat playlists))
                           errors)
                   cdr.f
                     (push (list "multi-file" (list pat playlists) f)
                           errors)
                   seen.c
                     (push (list "multi-string" (list pat playlists) list.c it)
                           errors))
              (each c f
                (= seen.c (list pat playlists)))
              (list c playlists)))))))

(def print-strings args
  (prn "  @strings")
  (each x (map car args)
    (prn "    " x)))

(def print-files (x)
  (prn "  @files")
  (each x x
    (prn "    " x)))

(def print-playlists args
  (prn "  @playlists")
  (each x (dedup:apply join (map cadr args))
    (prn "    " x)))

(let processed (obj)
  (def process-file (name)
    (or= processed.name
         (mappend (fn (x)
                    (if (caris x 'include)
                        (mappend process-file cdr.x)
                        x))
                  files.name))))

(def encode-path (s)
                    ; TODO relies on Nu specific changes to lib/strings.arc
  (string "file://" (urlencode-path:string cwd s)))

(def ->sxml (title files)
  (w/pretty:->xml
    `(playlist version  "1"
               xmlns    "http://xspf.org/ns/0/"
               xml:base ,cwd
       (title ,title)
       (trackList ,@(maplet x files
                      `(track (location ,encode-path.x)))))))

;=============================================================================
;  Input and processing
;=============================================================================
(let input car.script-args
  (zap todir input)
  (w/ cwd input
    (each name (dir ".")
      (if (dir-exists name)
            (debug "ignoring folder \"" input name "\"")
          (hidden-file? name)
            (debug "ignoring hidden file \"" input name "\"")
          (let value (w/infile s name nuit-parse.s)
            (normalize-file name value))))))

(let time (msec)
  (zap process-injective strings dirall-ext.filetypes)
  (debug "took " (- (msec) time) " msec to process all strings"))

;=============================================================================
;  Errors
;=============================================================================
(each (n x file other) errors
  (prn)
  (pr "@error ")
  (case n
    "no-file"
      (do (prn "string did not match any file")
          (print-strings x)
          (print-playlists x))
    "multi-file"
      (do (prn "string matched multiple files")
          (print-strings x)
          (print-files file)
          (print-playlists x))
    "multi-string"
      (do (prn "file was matched by multiple strings")
          (print-files file)
          (print-strings x other)
          (print-playlists x other))
    (err "invalid error message" n x file other)))

(when errors
  (prn)
  (prn "aborting due to errors")
  (quit 1))

;=============================================================================
;  Output
;=============================================================================
(each (file playlists . rest) strings
  (each x playlists
    (push (cons file rest) files.x)))

; TODO: ->sxml has to be run before w/ cwd
(let output cadr.script-args
  (zap todir output)
  (withs (all  dirall-ext.filetypes
          all  (->sxml "All" all))
    (w/ cwd output
      (w/outfile out "All.xspf"
        (disp all out))))
  (each (k v) files
    (iflet v process-file.k
      (let v (->sxml k v)
        (debug "writing to \"" output k ".xspf\"")
        (w/ cwd output
          (w/outfile out (+ k ".xspf")
            (disp v out))))
      (debug "ignoring playlist \"" k "\" because it is empty")))
)
