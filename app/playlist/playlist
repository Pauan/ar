#! /usr/bin/env arc

;; TODO: import is Nu specific
(import strings sxml boyer-moore parse-script-args) ; parse-script-args

;; TODO: parameter is Nu specific
(parameter current-playlist)
;(parameter current-asserts)
(parameter processed-trace) ;; infinite loop detection

(= files-by-title   (obj)
   processed        (obj)
   asserts          (obj)
   all-files        nil

   options          (obj)

   playlist-errors  (obj)
   other-errors     nil)


;; TODO: should be in strings.arc
#|(def xml-encode (s)
  (multisubst '(("&" "&amp;")
                ("<" "&lt;")) s))|#

(def encode-path (s)
                    ;; TODO: relies on Nu specific changes to lib/strings.arc
  (string "file://" (urlencode-path:string cwd s)))
;  (urlencode:multisubst '(("&" "&amp;")
;                                                (" " "%20")
;                                                ("<" "&lt;")
;                                                ("#" "")) s)

;; TODO: should be elsewhere
(def symdiff (x y)
  ;; TODO: inefficient
  (join (rem (fn (x) (some (fn (y) (is x y)) y)) x)
        (rem (fn (y) (some (fn (x) (is x y)) x)) y)))

(def duped (xs)
  ;; TODO: ew
  (with (h    (table)
         acc  nil)
    (each x xs
      (when h.x
        (push x acc))
      (set h.x))
    (rev acc)))


(def dirall-ext (exts)
  ;; TODO: dirall is Nu specific
  (dirall nil (fn (x)
                     ;; TODO: hidden-file? is Nu specific
                (and (no:hidden-file? x)
                         ;; TODO: dirname is Nu specific
                         ;; dirname
                     (or (dir-exists x)
                               ;; TODO: extension is Nu specific
                         (some (sym:downcase:extension x) exts))))))


;; other-err
(def oerr args
  (push (tostring:apply prn args)
        other-errors)
  nil)

;; playlist-err
(def perr args
  (zap2 string (tostring:apply prn "  -> " args)
                                      ;; TODO: current-playlist is Nu specific
               (playlist-errors:alref current-playlist 'title))
  nil)

(def perr-multi (x y)
  (case len.y
    0 (perr x "\"\"")
    1 (perr x "\"" car.y "\"")
    2 (perr x "\"" car.y "\" and \"" cadr.y "\"")
      (perr x "\"" car.y "\" ... \"" last.y "\"")))


;; TODO: find a way to not need to redef this, using a function argument, maybe?
(redef boyer-multi-match1 (patterns inputs every)
  (trues (fn (pat)
           (car:keep (fn (in)
                       (awhen (boyer-moore-search pat in)
                         (when every
                           (every car.pat in))
                         in))
                     inputs))
         patterns))

(def multi-string-filter (patterns
                          strings
                          (o missing  [perr "the pattern \"" _ "\" did not match anything"])
                          (o pattern  (fn (p l r)
                                        (perr "the pattern \"" p "\" matched both:\n      \"" l "\"\n      \"" r "\"")))
                          (o file     (fn (p l r)
                                        (perr "the file \"" p "\" was matched by both:\n      \"" l "\"\n      \"" r "\""))))
  (withs (track    (obj)
          files    (obj)
          patterns (rem (fn (x)
                          (when acons.x
                            (if (caris x 'ignore)
                                ;; debug is Nu specific
                                (perr "ignoring pattern \"" cadr.x "\"")
                                (perr "invalid expression: " x))
                            t))
                        patterns)
          matches  (boyer-multi-match patterns strings
                     (fn (x y)
                       (if files.y
                             (file y files.y x)
                           track.x
                             (pattern x track.x y))
                       (= files.y x
                          track.x y))))
    (each x patterns
      (unless track.x
        (missing x)))
    matches))

#|
(def process-asserts (x)
  (each x current-asserts process-asserts1.x))|#

(def include1 (x)
  (let c car.x
    (if (no x)
          nil
        (caris c 'title)
          (include1 cdr.x)
        (caris c 'w/playlist)
          (join (multi-string-filter cddr.c (include cadr.c))
                (include1 cdr.x))
        (caris c 'w/folder)
          (let n cadr.c
            ;; TODO: don't call (keep [posmatch ...] ...)
                                                                ;; TODO: dirname is Nu specific
            (join (multi-string-filter cddr.c (keep [posmatch n (dirname _)] all-files))
                  (include1 cdr.x)))
        (caris c 'w/all-files)
          (perr "w/all-files")
          #|(join (multi-string-filter cdr.c all-files)
                (include1 cdr.x))|#
        (caris c 'include)
          (join (mappend include cdr.c)
                (include1 cdr.x))
        (caris c 'assert)
          (do (zap2 join cdr.c asserts.current-playlist)
              ;(zap2 join cdr.c current-asserts)
              (include1 cdr.x))
        (do (perr "invalid expression: " c)
            (include1 cdr.x)))))

(def include (x)
  ;; % is Nu specific
  ;; grr, setting a hash key to nil deletes it,
  ;; so I have to use Racket's hash-ref! instead
  ((% hash-ref!) processed x (fn () (debug "processing playlist \"" x "\"")
                                    (iflet it files-by-title.x
                                          ;; infinite loop detection
                                      (if (some [is _ x] processed-trace)
                                          (let x rev.processed-trace
                                                                ;; TODO: ugly
                                            (w/current-playlist `((title ,car.x))
                                              (perr-multi "infinite cycle detected while including playlist " (or cdr.x x))
                                              #|
                                              ;; TODO: redundant, but maybe necessary...?
                                              (case len.x
                                                1 (perr "infinite cycle detected while including playlist \"" car.x "\"")
                                                2 (perr "infinite cycle detected while including playlist \"" cadr.x "\"")
                                                  (perr "infinite cycle detected while including playlists \"" cadr.x "\" ... \"" last.x "\""))|#
                                              ))
                                          ;; w/processed-trace is Nu specific
                                          (w/processed-trace (cons x processed-trace)
                                          ;; w/current-asserts is Nu specific
                                          ;(w/current-asserts nil
                                          ;; w/current-playlist is Nu specific
                                          (w/current-playlist it
                                            (let x include1.it
                                              ;(when current-asserts process-asserts.x)
                                              x))))
                                      (perr "tried to include playlist \"" x "\" but could not find it")))))

(def process-asserts1 (x)
  (withs (title  (alref current-playlist 'title)
          p      processed.title)
    (if (caris x 'contains)
          (each x cdr.x
            (if (is x 'all)
                (let l nil
                  (each (key x) processed
                    (when (isnt key title)
                      (zap2 join x l)))
                  (awhen (symdiff l p)
                    (perr-multi "assert failed: did not contain all files: " (sort < it))))
                (perr "invalid assert: " x)))
        (caris x 'no)
          (each x cdr.x
            (if (is x 'duplicates)
                (awhen duped.p
                  (perr-multi "assert failed: duplicate files detected: " (sort < it)))
                ;(prn:symdiff p dedup.p)
                (perr "invalid assert: " x)))
        (perr "invalid assert: " x))))


(def ->sxml (title files)
  (w/pretty:->xml
    `(playlist version  "1"
               xmlns    "http://xspf.org/ns/0/"
                        ;; cwd is Nu specific
               xml:base ,cwd
       (title ,title)
       (trackList ,@(map (fn (x)
                           `(track
                              (location ,encode-path.x)))
                         files)))))


;(require profile)
                    ;; TODO: Nu specific
(let (input output) (w/parse-args script-args
                      ("-v" "--version" ()
                        "Displays the version number and exits"
                        (prn "1.0")
                        (quit))
                      ("-d" "--debug" ()
                        "Prints additional messages"
                        (= debug? t))
                      ("-i" "--info" (t)
                        "Displays information about a template; doesn't write any files"
                        (= options!info t))
                      ;((in)  "Folder where you keep your templates")
                      ;((out) "Folder where the .xspf files are written to")
                      )
  (= all-files (dirall-ext '(flac flv mid mkv mp3 mp4 ogg ogm wav webm wma)))

  ;; TODO: Nu specific
  (zap todir input)
  (zap todir output)

  ;; TODO: Nu specific
  (w/cwd input
    (each x (dir ".")
          ;; TODO: Nu specific
      (if (hidden-file? x)
          ;; debug is Nu specific
          (debug "ignoring hidden file \"" input x "\"")
          (let info readfile.x
            (iflet x (alref info 'title)
              (= files-by-title.x info)
              (oerr " File \"" input x "\" doesn't have a top-level (title) expression"))))))

  ;(%.profile-thunk (fn ()
  (each (key val) files-by-title
    (include key))
  ;))

  (each (playlist asserts) asserts
    (w/current-playlist playlist
      (each x asserts process-asserts1.x)))

  (when (or other-errors
            keys.playlist-errors)
    (w/stdout (stderr)
      (each (key val) playlist-errors
        (prn " Playlist \"" key "\" has errors:")
        (prn val))
      (each x rev.other-errors
        (prn x))
      (prn " aborting due to errors")
      (quit 1)))

;; Arc posmatch
;  Total cpu time observed: 38236ms (out of 38326ms)
;  Number of samples taken: 751 (once every 51ms)

;; Boyer-Moore-Horspool
;  Total cpu time observed: 6396ms (out of 6432ms)
;  Number of samples taken: 126 (once every 51ms)

;; Boyer-Moore-Horspool with error checking
;  Total cpu time observed: 6928ms (out of 6968ms)
;  Number of samples taken: 136 (once every 51ms)

;; Boyer-Moore-Horspool with more error checking
;  Total cpu time observed: 6890ms (out of 6920ms)
;  Number of samples taken: 135 (once every 51ms)

  (aif options!info
       (prn "files: " (len processed.it))
       (each (key val) processed
         (let val (->sxml key val)
           ;; TODO: Nu specific
           (w/cwd output
             ;; debug is Nu specific
             (debug "writing to \"" output key ".xspf\"")
             (w/outfile out (+ key ".xspf")
               (disp val out)))))))
