#! /usr/bin/env arc

(import nuit/nuit-parse
        parse-script-args
        strings ; Only needed for urlencode-path
        sxml)

(parameter playlists  nil)
(parameter folders    nil)

(= version      "2.0"
   options      (obj)

   patterns     nil
   errors       nil
   files        (obj)

   filetypes    '(flac flv mid mkv mp3 mp4 ogg ogm wav webm wma)

   script-args  (w/parse-args script-args
                  ("-v" "--version" ()
                    "Displays the version number and exits"
                    (prn version)
                    (quit))
                  ("-d" "--debug" ()
                    "Prints additional messages"
                    (= debug? t))))
                  ;((in)  "Folder where you keep your templates")
                  ;((out) "Folder where the .xspf files are written to")

(def dirall-ext (exts)
  (dirall nil (fn (x)
                (and (no:hidden-file? x)
                         ; TODO use dirname ?
                     (or (dir-exists x)
                         (some (sym:downcase:extension x) exts))))))

(def process-pattern (x)
  (regexp (%.regexp-quote x)))

(def process-folder (x)
  (regexp:string "(?:^|/)"
                 (%.regexp-quote x)
                             ; TODO use last
                 (unless (is (x:- len.x 1) #\/) "/")))

(def normalize-file (k v)
  (w/playlists (cons k playlists)
    (awhenlet (x . rest) v
      (if acons.x
          (case car.x
            "title"    (= playlists (cons cadr.x cdr.playlists))
            "include"  (push (list* 'include (list car.playlists) cdr.x)
                             patterns)
            "playlist" (w/playlists (cons cadr.x playlists)
                         (self cddr.x))
            "folder"   (w/folders (cons (process-folder cadr.x) folders)
                         (self cddr.x)))
          (push (list x process-pattern.x folders rev.playlists)
                patterns))
      (self rest))))

; http://en.wikipedia.org/wiki/Injective_function
(def process-injective (patterns inputs)
  (debug "processing " len.patterns " patterns with " len.inputs " inputs")
  (let seen (obj)
    (maplet x patterns
      (if (isa car.x 'sym)
          x
          (let (pat proc folders playlists) x
            (withs (f  (trues (fn (file)
                                (and (%.regexp-match? proc file)
                                     (all [or (%.regexp-match? _ file) nil] folders)
                                     file))
                              inputs)
                    c  car.f)
              (aif no.f
                     (push (list "no-file" (list pat playlists))
                           errors)
                   cdr.f
                     (push (list "multi-file" (list pat playlists) f)
                           errors)
                   seen.c
                     (push (list "multi-pattern" (list pat playlists) list.c it)
                           errors))
              (each c f
                (= seen.c (list pat playlists)))
              (list c playlists)))))))

(def print-patterns args
  (prn "  @patterns")
  (each x (map car args)
    (prn "    " x)))

(def print-files (x)
  (prn "  @files")
  (each x x
    (prn "    " x)))

(def print-playlists args
  (prn "  @playlists")
  (each x (dedup:apply join (map cadr args))
    (prn "    " x)))

(let processed (obj)
  (def process-file (name)
    (or= processed.name
         (mappend (fn (x)
                    (if (caris x 'include)
                        (mappend process-file cdr.x)
                        x))
                  files.name))))

(def encode-path (s)
                    ; TODO relies on Nu specific changes to lib/strings.arc
  (string "file://" (urlencode-path:string cwd s)))

(def ->sxml (title files)
  (w/pretty:->xml
    `(playlist version  "1"
               xmlns    "http://xspf.org/ns/0/"
               xml:base ,cwd
       (title ,title)
       (trackList ,@(maplet x files
                      `(track (location ,encode-path.x)))))))

;=============================================================================
;  Input and processing
;=============================================================================
(let input car.script-args
  (zap todir input)
  (w/cwd input
    (each name (dir ".")
      (if (hidden-file? name)
          (debug "ignoring hidden file \"" input name "\"")
          (let value (w/infile s name nuit-parse.s)
            (normalize-file name value))))))

(let time (msec)
  (zap process-injective patterns dirall-ext.filetypes)
  (debug "took " (- (msec) time) " msec to process all patterns"))

;=============================================================================
;  Errors
;=============================================================================
(each (n x file other) errors
  (prn)
  (pr "@error ")
  (case n
    "no-file"
      (do (prn "pattern did not match any file")
          (print-patterns x)
          (print-playlists x))
    "multi-file"
      (do (prn "pattern matched multiple files")
          (print-patterns x)
          (print-files file)
          (print-playlists x))
    "multi-pattern"
      (do (prn "file was matched by multiple patterns")
          (print-files file)
          (print-patterns x other)
          (print-playlists x other))
    (err "invalid error message" n rest)))

(when errors
  (prn)
  (prn "aborting due to errors")
  (quit 1))

;=============================================================================
;  Output
;=============================================================================
(each (file playlists . rest) patterns
  (each x playlists
    (push (cons file rest) files.x)))

(let output cadr.script-args
  (zap todir output)
  (each (k v) files
    (iflet v process-file.k
      (let v (->sxml k v)
        (w/cwd output
          (debug "writing to \"" output k ".xspf\"")
          (w/outfile out (+ k ".xspf")
            (disp v out))))
      (debug "ignoring playlist \"" k "\" because it is empty"))))
