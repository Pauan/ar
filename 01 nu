#lang racket/base
;; Arc/Nu Compiler -- Manifest Destiny
;; http://www.youtube.com/watch?v=qXp3qjeM0e4

;; TODO: look for uses of null? and replace them with empty-stream? as needed
;; TODO: use Racket's custom write/display stuff, so that printing infinite lists works
;; TODO: keyword args ???

(provide (all-defined-out))

(require ffi/unsafe)
(require racket/unsafe/ops)
(require racket/path)
(require racket/port)
(require racket/system)
(require racket/tcp)

;; Layer 1
(define atstrings        #f)
(define direct-calls     #f)
(define inline-calls     #f)
(define explicit-flush   #f)

(define nocompile        (gensym)) ; if in the car the expression won't be compiled
(define sig              (make-hasheq))
(define names            (make-hasheq))
(define t                't)
(define nil              null)

(define filename         (make-parameter #f))

(define hygienic-macros? (make-parameter #t))
(define hyper-static?    (make-parameter #t))

(define import-cache     (make-parameter #f))
(define import-dirs      (make-parameter null))

(define local?           (make-parameter #f))
(define locals           (make-parameter (hasheq)))

(define orig-globals     (make-parameter #f))
(define globals          (make-parameter (hasheq)))

(define ac-fn-let*       (make-parameter #f))
(define uniq-counter     (make-parameter 1))

; make sure only one thread at a time executes anything
; inside an atomic-invoke. atomic-invoke is allowed to
; nest within a thread; the thread-cell keeps track of
; whether this thread already holds the lock.
(define the-sema  (make-semaphore 1))
(define sema-cell (make-thread-cell #f))

; there are two ways to close a TCP output port.
; (close o) waits for output to drain, then closes UNIX descriptor.
; (force-close o) discards buffered output, then closes UNIX desc.
; web servers need the latter to get rid of connections to
; clients that are not reading data.
; mzscheme close-output-port doesn't work (just raises an error)
; if there is buffered output for a non-responsive socket.
; must use custodian-shutdown-all instead.
(define custodians (make-hash))

(struct box (uniq file [get #:auto #:mutable]
                       [set #:auto #:mutable])
  #:constructor-name make-box
  #:guard (lambda (uniq file _)
            (if (symbol-interned? uniq)
                (values (string->uninterned-symbol (symbol->string uniq)) file)
                (values uniq file)))
  #:methods gen:custom-write
    [(define (write-proc x port mode)
       (display "#<box:" port)
       (display (box-uniq x) port)
       (display ">" port))])

(struct tagged (type rep)
  ;; TODO: make mutable later, maybe
  ;#:mutable
  #:methods gen:custom-write
    [(define (write-proc x port mode)
       (begin (display "#(tagged " port)
              (display (tagged-type x) port)
              (display " " port)
              (display (tagged-rep x) port)
              (display ")" port)))])

; TODO: is there seriously no built-in way to do this?
(define (->pair x)
  (cond ((null? x)
          x)
        ((null? (cdr x))
          (list (list (car x))))
        (else
          (cons (list (car x) (cadr x))
                (->pair (cddr x))))))

(define (hash-if-key hash key yes no)
  (if (hash-has-key? hash key)
      (yes hash (hash-ref hash key))
      (no hash)))

(define (fraction? x)
  (and (number? x)
       (exact? x)
       (not (integer? x))))

(define (iround x) (inexact->exact (round x)))

(define (is? x y)
  (or (eqv? x y)
      (and (string? x) (string? y) (string=? x y))
      ;; TODO: why is this here in Arc 3.1?
      ;(and (false? x) (false? y))
      ))

;; generic comparison
(define (make-comparer a b c)
  (lambda (x y)
          ;; TODO: better ordering for speed
    (cond ((number? x)  (a x y))
          ((string? x)  (b x y))
          ((char? x)    (c x y))
          ((symbol? x)  (b (symbol->string x)
                           (symbol->string y)))
          (else         (a x y)))))

;; based on Arc's reduce. Can't use foldl because it doesn't work well with
;; multiple types (e.g. +-2)
(define (reduce f xs)
  (if (null? (cdr xs))
      (car xs) ;(f (car xs))
      (reduce f (cons (f (car xs) (cadr xs)) (cddr xs)))))

; First unescaped @ in s, if any.  Escape by doubling.
(define (atpos s i)
         ;; TODO: shouldn't this use = ?
  (cond ((eqv? i (string-length s))
          #f)
        ((eqv? (string-ref s i) #\@)
          (if (and (< (+ i 1) (string-length s))
                   (not (eqv? (string-ref s (+ i 1)) #\@)))
              i
              (atpos s (+ i 2))))
        (else
          (atpos s (+ i 1)))))

(define (unescape-ats s)
  (list->string (let self ((cs (string->list s)))
                  (cond ((null? cs)
                          cs)
                        ((and (eqv? (car cs) #\@)
                              (not (null? (cdr cs)))
                              (eqv? (cadr cs) #\@))
                          (self (cdr cs)))
                        (else
                          (cons (car cs) (self (cdr cs))))))))

(define (dottedrec f xs)
  (let self ((xs xs))
    (if (pair? xs)
        (cons (f (self (car xs)))
              (self (cdr xs)))
        (f xs))))

;; the next two are optimizations, except work for macros.
(define (de-compose fns args)
        ;; TODO: is this needed anywhere in Arc or can I remove it...?
  (if ;(null? fns)       `((fn vals (car vals)) ,@args)
      (null? (cdr fns)) (cons (car fns) args)
                        (list (car fns) (de-compose (cdr fns) args))))

(define (de-andf f args)
  (let ((gs (map (lambda (x) (gensym)) args)))
    `((,(->orig-box 'fn) ,gs
        (,(->orig-box 'and) ,@(map (lambda (f) (cons f gs))
                                   (cdr f))))
      ,@args)))

#|(define (keyword-args? args)
  (let self ((x args))
    (if (pair? x)
        (if (keyword? (car x))
            #t
            (self (cdr x)))
        #f)))|#

(define (ac-car x)
  (cond ((pair? x)
          (unsafe-car x))
        ((null? x)
          x)
        (else
          (raise-type-error 'car "cons" x))))

(define (ac-cdr x)
  (cond ((pair? x)
          (unsafe-cdr x))
        ((null? x)
          x)
        (else
          (raise-type-error 'cdr "cons" x))))

;; Layer 2
;; convert Racket booleans to Arc booleans
(define (tnil x) (if x t nil))

(define (sym->nil x)
  (if (eq? x 'nil) nil x))

;; definition of falseness for Arc's if
(define (false? x)
  (or (eq? x nil)
      (eq? x #f)))

(define (type x)
        ;; TODO: better ordering for speed
  (cond ((tagged? x)         (tagged-type x))
        ((namespace? x)      'namespace)
        ((pair? x)           'cons)
        ;((stream? x)         'stream) ;; TODO: not sure about this
        ((symbol? x)         'sym) ;; TODO: a type for boxes? overload 'sym?
        ((null? x)           'sym) ; (type nil) -> sym
        ((procedure? x)      'fn)
        ((char? x)           'char)
        ((string? x)         'string)
        ((exact-integer? x)  'int)
        ((number? x)         'num)     ; unsure about this
        ((hash? x)           'table)
        ((output-port? x)    'output)
        ((input-port? x)     'input)
        ((tcp-listener? x)   'socket)
        ((exn? x)            'exception)
        ((thread? x)         'thread)
                             ;(err "type: unknown type" x)
                             ;; TODO: not sure about this, but seems okay
        (else                nil)))

;; (pairwise pred '(a b c d)) =>
;;   (and (pred a b) (pred b c) (pred c d))
;; pred returns #t/#f, pairwise returns t/nil
(define (pairwise pred lst)
        ; TODO: does this need to check the cdr?
  (cond ((null? (cdr lst))
          t)
        ((pred (car lst) (cadr lst))
          (pairwise pred (cdr lst)))
        (else nil)))

(define (make-reduce f init)
  (case-lambda
    ((x y) (f x y))
    ((x)   x)
    (()    init)
    (args  (reduce f args))))

;; Non-fn constants in functional position are valuable real estate, so
;; should figure out the best way to exploit it.  What could (1 foo) or
;; ('a foo) mean?  Maybe it should mean currying.
;;
;; For now the way to make the default val of a hash table be other than
;; nil is to supply the val when doing the lookup.  Later may also let
;; defaults be supplied as an arg to table.  To implement this, need: an
;; eq table within scheme mapping tables to defaults, and to adapt the
;; code in arc.arc that reads and writes tables to read and write their
;; default vals with them.  To make compatible with existing written tables,
;; just use an atom or 3-elt list to keep the default.
;;
;; experiment: means e.g. [1] is a constant fn
;;       ((or (number? fn) (symbol? fn)) fn)
;; another possibility: constant in functional pos means it gets
;; passed to the first arg, i.e. ('kids item) means (item 'kids).
(define ref
  (case-lambda
    ((x k)    (cond ((hash? x)    (hash-ref x k nil))
                    ((string? x)  (string-ref x k))
                    ((pair? x)    (list-ref x k))
                    (else         (error "function call on inappropriate object" x k))))
    ((x k d)  (if   (hash? x)     (hash-ref x k d)
                                  (error "function call on inappropriate object" x k d)))
    (args     (apply error "function call on inappropriate object" args))))

;; All of this is for atstrings, not needed for normal strings at all
(define (codestring s)
  (let ((i (atpos s 0)))
    (if i  (cons (substring s 0 i)
                 (let* ((rest (substring s (+ i 1)))
                        (in   (open-input-string rest))
                        (expr (read in))
                        (i2   (let-values (((x y z) (port-next-location in))) z)))
                   (close-input-port in)
                   (cons expr (codestring (substring rest (- i2 1))))))
           (list s))))

;; Layer 3
(define (true? x)
  (not (false? x)))

;; TODO: list + table of types for coerce
(define (coerce x to (base 10))
  (cond ((tagged? x)         (error "can't coerce annotated object"))
        ((is? to (type x))   x)
        ((symbol? x)         (case to
                              ((string)  (symbol->string x))
                              (else      (error "can't coerce" x to))))
        ((pair? x)           (case to
                              ((string)  (apply string-append
                                                (map (lambda (y) (coerce y 'string))
                                                     x)))
                              (else      (error "can't coerce" x to))))
        ;(eq? x nil)
        ((null? x)           (case to
                              ((string)  "")
                              (else      (error "can't coerce" x to))))
        ((char? x)           (case to
                              ((int)     (char->integer x))
                              ((string)  (string x))
                              ((sym)     (string->symbol (string x)))
                              (else      (error "can't coerce" x to))))
        ((exact-integer? x)  (case to
                              ((num)     x)
                              ((char)    (integer->char x))
                              ((string)  (number->string x base))
                              (else      (error "can't coerce" x to))))
        ((number? x)         (case to
                              ((int)     (iround x))
                              ((char)    (integer->char (iround x)))
                              ((string)  (number->string x base))
                              (else      (error "can't coerce" x to))))
        ((string? x)         (case to
                              ((sym)     (string->symbol x))
                              ((cons)    (string->list x))
                              ((num)     (or (string->number x base)
                                             (error "can't coerce" x to)))
                              ((int)     (let ((n (string->number x base)))
                                           (if n  (iround n)
                                                  (error "can't coerce" x to))))
                              (else      (error "can't coerce" x to))))
        (else                (error "can't coerce" x to))))

(define (make-pairwise f)
  (case-lambda
    ((x y) (tnil (f x y)))
    ((x)   t)
    (()    t)
    (args  (pairwise f args))))

;; call a function or perform an array ref, hash ref, etc.
(define call
  ;; uses case-lambda for ridiculous speed: now using call for *all* function
  ;; calls is just as fast as using the funcall functions, and unlike
  ;; funcall, this hardcodes up to 6 arguments rather than only 4
  ;;
  ;; I could go higher but it'd be kinda pointless and would just make the
  ;; definition of call even bigger than it already is
  (case-lambda
    ((x)              (if (procedure? x)
                          (x)
                          (ref x)))
    ((x a)            (if (procedure? x)
                          (x a)
                          (ref x a)))
    ((x a b)          (if (procedure? x)
                          (x a b)
                          (ref x a b)))
    ((x a b c)        (if (procedure? x)
                          (x a b c)
                          (ref x a b c)))
    ((x a b c d)      (if (procedure? x)
                          (x a b c d)
                          (ref x a b c d)))
    ((x a b c d e)    (if (procedure? x)
                          (x a b c d e)
                          (ref x a b c d e)))
    ((x a b c d e f)  (if (procedure? x)
                          (x a b c d e f)
                          (ref x a b c d e f)))
    ((x . args)       ;(prn "warning: called with 7+ arguments:" x args)
                      (if (procedure? x)
                          (apply x args)
                          (apply ref x args)))))

;; Layer 4
(define (macro? x yes no)
  (let ((b (lookup x
             (lambda (x) x)
             (lambda ()  x))))
    (if (and (tagged? b)
             (eq? (tagged-type b) 'mac))
        (yes (tagged-rep b))
        (no))))

;; generic +: strings, lists, numbers.
;; return val has same type as first argument.
(define (ac-+ x y)
        ;; TODO: better ordering for speed
  (cond ((number? x)  (+ x y))
        ((string? x)  (string-append x (coerce y 'string)))
        ((list? x)    (append x y))
        ;; TODO: check the behavior of Arc 3.1 for (+ "foo" #\a) and (+ #\a "foo")
        ((char? x)    (string-append (string x) (coerce y 'string)))
        (else         (+ x y))
                      ;(err "can't + " x " with " y)
                      ))

;; Layer 5
(define (macex1 e)
  (if (pair? e)
      (macro? (car e)
        (lambda (x)
          (let ((x (apply x (cdr e))))
            (if (eq? (car x) nocompile)
                e
                x)))
        (lambda () e))
      e))

(define (fn-call-normal x args)
  (let ((r (ac x)))
            ;; optimization for (#<fn> ...) and ((fn ...) ...)
    (if (or (procedure? r)
            (and (pair? r)
                 (eq? (car r) 'lambda))
            ;; needed because call doesn't accept keyword args
            ;(keyword-args? args)
            )
        (cons r (ac-all args))
        (list* call r (ac-all args)))))

(define (fn-call x args)
  (lookup x
    (lambda (f)
            ;; inserts the actual value for things in functional position, so
            ;; (+ 1 2) compiles into (#<fn:+> 1 2)
            ;;
            ;; this is much faster than direct-calls but it's even more strict:
            ;; if you redefine any global, even functions, those changes aren't
            ;; retroactive: they affect new code, but not old code
      (cond (inline-calls
              (if (procedure? f)
                  (cons f (ac-all args))
                  (list* ref f (ac-all args))))
            ;; (foo bar) where foo is a global variable bound to a procedure.
            ;; this breaks if you redefine foo to be a non-fn (like a hash table)
            ;; but as long as you don't redefine anything, it's faster
            ((and direct-calls
                  (procedure? f))
              (cons (ac x) (ac-all args)))
            (else
              (fn-call-normal x args))))
    (lambda ()
      (fn-call-normal x args))))

(define (mac-call x y)
  (macro? x
    (lambda (x) (ac (apply x y)))
    (lambda ()  (fn-call x y))))

(define (ac-call f args)
  (when (ssyntax? f)
    (set! f (ssexpand f)))
  (if (pair? f)
      (let ((c (car f)))
        (macro? c
          (lambda (_)
            (cond ((orig-box? c 'compose)
                    (ac (de-compose (cdr f) args)))
                  ((orig-box? c 'complement)
                    (ac (list (->orig-box 'no) (cons (cadr f) args))))
                  ((orig-box? c 'andf)
                    (ac (de-andf f args)))
                  (else
                    (mac-call f args))))
          (lambda ()
            (mac-call f args))))
      (mac-call f args)))

(define (ac-string s)
  (if atstrings
      (if (atpos s 0)
          (ac (cons (->orig-box 'string)
                    (map (lambda (x)
                           (if (string? x)
                               (unescape-ats x)
                               x))
                         (codestring s))))
          (unescape-ats s))
      ;; This is for normal strings
      (string-copy s))) ; avoid immutable strings

(define (ac x)
  (cond ((symbol? x)
          (if (ssyntax? x)
              (ac (ssexpand x))
              (ac (->box x))))
        ((box? x)
          (if (box-get x)
              (ac ((box-get x)))
              (box-uniq x)))
        ((pair? x)
          (if (eq? (car x) nocompile)
              (cdr x)
              (ac-call (car x) (cdr x))))
        ((null? x)
          ;; this causes it to return null
          ;null
          `(quote ,x))
        ((string? x)
          (ac-string x))
        (else x)))

(define (ac-all x)
  (let self ((x x))
    (if (pair? x)
        (cons (ac (car x))
              (self (cdr x)))
        x)))

(define (pairfn f x)
  (if (null? (cdr x))
      (cons (f (car x) null)
            ;; this is so the assign form returns the value
            (list (ac (car x))))
               ;; TODO: why does Arc 3.1 call macex here?
      (cons (f (car x) (cadr x))
            (if (null? (cddr x))
                (list (ac (car x)))
                (pairfn f (cddr x))))))

;; Layer 6
(define (macex e)
  (let ((v (macex1 e)))
    (if (eq? v e)
        v
        (macex v))))

(define-syntax def
  (syntax-rules ()
    ((_ name parms #:sig sig . body)
      (set-sig 'name 'sig (let ((name (lambda parms . body))) name)))
    ((_ name parms . body)
      (set-sig 'name 'parms (let ((name (lambda parms . body))) name)))))

(define-syntax mac
  (syntax-rules ()
    ((_ name parms #:sig sig . body)
      (set-sig 'name 'sig
        (tagged 'mac (let ((name (lambda parms . body))) name))))
    ((_ name parms . body)
      (set-sig 'name 'parms
        (tagged 'mac (let ((name (lambda parms . body))) name))))))

(define-syntax assign
  (syntax-rules ()
    ((_ name #:sig sig value)
      (set-sig 'name 'sig value))
    ((_ name value)
      (set-name 'name value))))

; qq-expand takes an Arc list containing a quasiquotation expression
; (the x in `x), and returns an Arc list containing Arc code.  The Arc
; code, when evaled by Arc, will construct an Arc list, the
; expansion of the quasiquotation expression.
;
; This implementation is a modification of Alan Bawden's quasiquotation
; expansion algorithm from "Quasiquotation in Lisp"
; http://repository.readscheme.org/ftp/papers/pepm99/bawden.pdf
(define (qq-atom x)
  (if (symbol? x)
      (if (hygienic-macros?)
          (->box x)
          (list (->orig-box 'quote) x))
      x))

(define (qq-expand x)
  (if (pair? x)
      (let ((c (car x)))
        (cond ((orig-box? c 'unquote)
                (cadr x))
              ((orig-box? c 'unquote-splicing)
                (error ",@ cannot be used immediately after `"))
              ((orig-box? c 'quasiquote)
                (qq-expand (qq-expand (cadr x))))
              (else
                (qq-expand-pair x))))
      (qq-atom x)))

(define (qq-expand-pair x)
  (if (pair? x)
      (let ((c (car x)))
        (cond ((and (orig-box? c 'unquote)
                    (null? (cddr x)))
                (cadr x))
              ((and (orig-box? c 'unquote-splicing)
                    (null? (cddr x)))
                (error "cannot use ,@ after ."))
              ((pair? c)
                (cond ((orig-box? (car c) 'unquote)
                        (list cons (cadr c)
                                   (qq-expand-pair (cdr x))))
                      ((orig-box? (car c) 'unquote-splicing)
                        (if (null? (cdr x))
                            (cadr c)
                            (list append (cadr c)
                                         (qq-expand-pair (cdr x)))))
                      ((orig-box? (car c) 'quasiquote)
                        (list cons (qq-expand-pair (qq-expand (cadr c)))
                                   (qq-expand-pair (cdr x))))
                     (else
                       ;; TODO: code duplication
                       (list cons (qq-expand-pair c)
                                  (qq-expand-pair (cdr x))))))
              (else
                (list cons (qq-expand-pair c)
                           (qq-expand-pair (cdr x))))))
      (qq-atom x)))

; (if)           -> nil
; (if x)         -> x
; (if t a ...)   -> a
; (if nil a b)   -> b
; (if nil a b c) -> (if b c)
(define (ac-if args)
        ;; TODO: maybe simplify this a little, like by using ac-cdr
  (cond ((null? args)
          (ac nil)) ; TODO: hardcodes null, rather than using the variable 'nil
        ((null? (cdr args))
          (ac (car args)))
        (else
          ;; TODO: fix this if I expose true? to Arc
          `(if (,true? ,(ac (car args)))
               ,(ac (cadr args))
               ,(ac-if (cddr args))))))

(define (w/init dir path f)
  ;; This is so that it's possible to retrieve the column/line of an input port
  ; (port-count-lines-enabled #t)
  (parameterize ((current-readtable arc-readtable)
                 (filename (path->string path))
                 (globals (globals))
                 (import-cache (make-hash))
                 (import-dirs (list* (path->string (build-path dir "lib"))
                                     (import-dirs)))
                 (orig-globals (make-hasheq))
                 (hyper-static? #f)
                 (hygienic-macros? #f)
                 (compile-allow-set!-undefined #t))
    (init)
    ;; These files have Arc/Nu's dir prefixed to them
    ;; and are automatically loaded when Arc/Nu
    ;; starts up.
    (for ((x (list "02 arc"
                   "03 utils"
                   "04 paths"
                   "lib/strings"
                   "lib/re")))
      (ac-load (build-path dir x)))
    (f ac-load)))

;=============================================================================
;  import
;=============================================================================
; sread = scheme read. eventually replace by writing read
(define (sread p eof)
  (let ((expr (read p)))
    (if (eof-object? expr)
        eof
        (dottedrec sym->nil expr)))) ; TODO: why does this call sym->nil?

; TODO: use coerce?
(define (->string x)
  (cond ((symbol? x)
          (symbol->string x))
        ((path? x)
          (path->string x))
        ((string? x)
          x)
        (else #f)))

(define (exists? p dir file none)
  (cond ((file-exists? p)
          (file p))
        ((directory-exists? p)
          (dir p))
        (else
          (none))))

(define (abspath x y)
  (path->string
    (normal-case-path
      (simplify-path
        (resolve-path
          (path->complete-path (expand-user-path x) y))))))

(define (find-filename p dir file none)
  (let self ((x (import-dirs)))
    (if (pair? x)
        (let ((p (abspath p (car x))))
          (exists? p dir file
            (lambda ()
                       ; TODO: don't hardcode .arc?
              (exists? (string-append p ".arc") dir file
                (lambda ()
                  (self (cdr x)))))))
        (none p))))

(define (load-file p)
  (parameterize ((filename p)
                 (import-dirs (cons (path-only p) ; TODO: is this good?
                                    (import-dirs))))
    (let ((old (globals)))
      (call-with-input-file p
        (lambda (x)
          (let self ()
            (let ((x (sread x eof)))
              (if (eof-object? x)
                  ; TODO: how am I going to handle deletions?
                  ;       maybe, rather than using a table, use a list of
                  ;       functions, each of which sets or removes from the
                  ;       global hash table
                  (let ((new (make-hasheq)))
                    (hash-diff old (globals) (lambda (key val)
                      (hash-set! new key val)))
                    new)
                  (begin (eval (ac x))
                         (self))))))))))

(define (ac-load p [reimport? #f])
  (find-filename (->string p)
    (lambda (p)
      (import-dirs (cons p (import-dirs))))
    (lambda (p)
      (if reimport?
          (hash-set! (import-cache) p (load-file p))
          (hash-if-key (import-cache) p
            (lambda (x y)
              (let ((hash (globals)))
                (hash-for-each y
                  (lambda (key val)
                    (set! hash (hash-set hash key val))))
                (globals hash)))
            (lambda (x)
              (hash-set! x p (load-file p)))))
      (void))
    (lambda (p)
      (error (string-append "file \"" p "\" was not found")))))

;=============================================================================
;  fn
;=============================================================================
(define (ac-fn-push x y)
  (ac-fn-let* (cons (list x y) (ac-fn-let*))))

(define (ac-fn-destructure-cdr u args)
  (when (not (null? (cdr args)))
    (ac-fn-push u (list ac-cdr u))))

(define (ac-fn-destructure-car u x args)
  (ac-fn-push x (list ac-car u))
  (ac-fn-destructure-cdr u args))

(define (ac-fn-optional args)
  (let ((args (cddar args)))
    (if (null? args)
        (ac nil)
        (ac (car args)))))

(define (ac-fn-destructure u args)
  (cond ((pair? args)
          (if (pair? (car args))
              (if (eq? (caar args) 'o)
                  (begin (ac-fn-push (box-uniq (make-local-box (cadar args)))
                                     `(if (,pair? ,u)
                                          (,car ,u)
                                          ,(ac-fn-optional args)))
                         (ac-fn-destructure-cdr u args)
                         (ac-fn-destructure u (cdr args)))
                  (let ((v (gensym)))
                    (ac-fn-destructure-car u v args)
                    (ac-fn-destructure v (car args))
                    (ac-fn-destructure u (cdr args))))
              (begin (ac-fn-destructure-car u (box-uniq (make-local-box (car args))) args)
                     (ac-fn-destructure u (cdr args)))))
        ((not (null? args))
          (ac-fn-push (box-uniq (make-local-box args)) u))))

(define (ac-fn-args args)
  (cond ((pair? args)
          (if (pair? (car args))
              (if (eq? (caar args) 'o)
                  (cons (list (box-uniq (make-local-box (cadar args)))
                              (ac-fn-optional args))
                        (ac-fn-args (cdr args)))
                  (let ((u (gensym)))
                    (ac-fn-destructure u (car args))
                    (cons u (ac-fn-args (cdr args)))))
              (cons (box-uniq (make-local-box (car args)))
                    (ac-fn-args (cdr args)))))
        ((null? args)
          args)
        (else
          (box-uniq (make-local-box args)))))

(define (ac-fn parms body)
  (parameterize ((local? #t)
                 (locals (locals))
                 (ac-fn-let* null))
    (let* ((parms (ac-fn-args parms))
           (body  (ac-all (if (null? body)
                              (list nil)
                              body))))
      (if (null? (ac-fn-let*))
          `(lambda ,parms ,@body)
          `(lambda ,parms
             (let* ,(reverse (ac-fn-let*)) ,@body))))))

;=============================================================================
;  I/O
;=============================================================================
(define (read-square-brackets ch port src line col pos)
  `(square-brackets ,@(read/recursive port #\[ #f)))

(define (read-curly-brackets ch port src line col pos)
  `(curly-brackets ,@(read/recursive port #\{ #f)))

#|(define (read-keyword ch port src line col pos)
  (read/recursive (input-port-append #t (open-input-string "#:") port) #f #f))|#

(define arc-readtable
  (make-readtable #f #\[ 'terminating-macro read-square-brackets
                     #\{ 'terminating-macro read-curly-brackets
                     ;#\: 'non-terminating-macro read-keyword
                     ))

;; TODO: not exposed to Arc, but maybe should be
(define (close1 p)
  (cond ((input-port? p)    (close-input-port p))
        ((output-port? p)   (close-output-port p))
        ((tcp-listener? p)  (tcp-close p))
        (else               (error "can't close " p))))

(define (warn . args)
  (display "warning: " (current-error-port))
  (for ((x args))
    (display x (current-error-port)))
  (newline (current-error-port)))

(define (associate-custodian c i o)
  (hash-set! custodians i c)
  (hash-set! custodians o c))

; if a port has a custodian, use it to close the port forcefully.
; also get rid of the reference to the custodian.
; sadly doing this to the input port also kills the output port.
(define (try-custodian p)
  (let ((c (hash-ref custodians p #f)))
    (if c (begin (custodian-shutdown-all c)
                 (hash-remove! custodians p)
                 #t)
          #f)))

(define (read-from-string str)
  (let* ((port  (open-input-string str))
         (val   (read port)))
    (close-input-port port)
    val))

(define (make-write f)
  (lambda (c (out (current-output-port)))
    (f c out)
    c))

(define (make-read f)
  (lambda ((in (current-input-port)) (eof nil))
    (let ((x (f in)))
      (if (eof-object? x) eof x))))

(define (->name x)
  (or (hash-ref names x #f)
      (and (not (tagged? x))
           (object-name x))))

(define (nameit x y)
        ; TODO: code duplication with macro?
  (when (and (tagged? y)
             (eq? (tagged-type y) 'mac))
    ; TODO: this uses symbols rather than boxes
    (hash-set! names y x))
  (if (procedure? y)
      (procedure-rename y x)
      y))

(define (print-w/name x l m r port)
  (let ((x (->name x)))
    (display l port)
    (when x
      (display m port)
      (display x port))
    (display r port)))

(define (print-w/list f x port)
  (display "(" port)
  (let self ((x x))
    (if (pair? x)
        (begin (print f (car x) port)
               (unless (null? (cdr x))
                 (display " " port)
                 (self (cdr x))))
        (begin (display ". " port)
               (print f x port))))
  (display ")" port))

(define (print f x port)
        ;; TODO: should probably use (no x) or whatever
  (cond ((null? x)           (display "nil" port))
        ;; TODO: maybe use isa for pair? and procedure?
        ((pair? x)           (print-w/list f x port))
        #|((keyword? x)        (begin (display ":" port)
                                    (display (keyword->string x) port)))|#
        ((procedure? x)      (print-w/name x "#<fn" ":" ">" port))
        ((eq? (type x) 'mac) (print-w/name x "#<mac" ":" ">" port))
        ((fraction? x)       (f (exact->inexact x) port))
        (else                (f x port)))
  nil)

(define (make-print f)
  (lambda (x (out (current-output-port)))
    (print f x out)
    (unless explicit-flush (flush-output out))
    nil))

;=============================================================================
;  Boxes
;=============================================================================
(define (set!-box name a b f)
  (let* ((b  (if (global? a)
                 (list nameit `(quote ,a) (ac b))
                 (ac b)))
         (a  (if (symbol? a)
                 (f a)
                 a)))
    (if (box? a)
        (if (box-set a)
            (ac ((box-set a) (cons nocompile b))) ; TODO: ew, but I don't know of a better way
            `(set! ,(box-uniq a) ,b))
        (error (string-append "first argument to " name " must be a symbol:") a))))

(define (ac-assign a b)
  (set!-box "assign" a b ->box))

(define (ac-var a b)
  (set!-box "var" a b
    (lambda (x)
      (if (local?)
          (let ((x (make-local-box x)))
            (ac-fn-push (box-uniq x) #f)
            x)
          (make-global-box x)))))

(define (make-global-box x)
  (let ((r (make-box x (filename))))
    (globals (hash-set (globals) x r))
    r))

(define (make-local-box x)
  (let ((r (make-box x (filename))))
    (locals (hash-set (locals) x r))
    r))

; Used to create new global boxes, if they don't already exist
(define (->global-box! x)
  (hash-ref (globals) x
    (lambda ()
      (make-global-box x))))

; Used to convert a symbol to a box
(define (->box x)
  (hash-ref (locals) x
    (lambda ()
      (hash-ref (globals) x
        (lambda ()
          (if (hyper-static?)
              (error "undefined variable:" x)
              (make-global-box x)))))))

; Like ->box except it returns #f if the box doesn't exist
(define (->safe-box x)
  (hash-ref (locals) x
    (lambda ()
      (hash-ref (globals) x
        (lambda () #f)))))

; Returns the original (first-created) box
(define (->orig-box x)
  (hash-ref! (orig-globals) x
    (lambda ()
      (->global-box! x))))

(define (orig-box? x y)
  (when (symbol? x)
    (set! x (->safe-box x)))
  (if (box? x)
      (eq? (->orig-box y) x)
      #f))

(define (global? x)
  (and (symbol? x)
       (not (hash-has-key? (locals) x))))

(define (lookup x yes no)
  (when (and (global? x)
             (hash-has-key? (globals) x))
    (set! x (hash-ref (globals) x)))
  (if (box? x)
      (let* ((u (gensym))
             (x (namespace-variable-value
                  (box-uniq x)
                  #f
                  (lambda () u))))
        (if (eq? x u)
            (no)
            (yes x)))
      (no)))

(define (set-raw n v)
  (namespace-set-variable-value!
    (box-uniq (->global-box! n))
    v
    #f))

(define (set-name n v)
  (set-raw n (nameit n v)))

(define (set-sig n s v)
  ; TODO: this uses symbols rather than boxes
  (hash-set! sig n s)
  (set-name n v))

(define (w/-maker body f)
  (let* ((old  (globals))
         (body (ac-all body))
         (new  (globals)))
    (globals (f old new))
    (cons nocompile
      `(begin ,@body))))

(define (w/exclude old new x)
  (if (hash-has-key? old x)
      (hash-set new x (hash-ref old x))
      (hash-remove new x)))

(define (hash-diff old new f)
  (hash-for-each new
    (lambda (key val)
      (when (or (not (hash-has-key? old key))
                (not (eq? (hash-ref old key) val)))
        (f key val)))))

;=============================================================================
;  ssyntax
;=============================================================================
; Though graphically the right choice, can't use _ for currying
; because then _!foo becomes a function.  Maybe use <>.  For now
; leave this off and see how often it would have been useful.

; Might want to make ~ have less precedence than &, because
; ~foo&bar prob should mean (andf (complement foo) bar), not
; (complement (andf foo bar)).
(define (symbol->chars x) (string->list (symbol->string x)))

;; TODO: why does this count backwards...? efficiency, maybe?
(define (has-ssyntax-char? string i)
  (and (>= i 0)
       (or (let ((c (string-ref string i)))
             (or (eqv? c #\:) (eqv? c #\~)
                 (eqv? c #\&)
                 ;(eqv? c #\_)
                 (eqv? c #\.)  (eqv? c #\!)))
           (has-ssyntax-char? string (- i 1)))))

(define (tokens test source token acc keepsep?)
  (cond ((null? source)
          (reverse (if (pair? token)
                       (cons (reverse token) acc)
                       acc)))
        ((test (car source))
          (tokens test
                  (cdr source)
                  null
                  (let ((rec (if (null? token)
                                 acc
                                 (cons (reverse token) acc))))
                    (if keepsep?
                        (cons (car source) rec)
                        rec))
                  keepsep?))
        (else
          (tokens test
                  (cdr source)
                  (cons (car source) token)
                  acc
                  keepsep?))))

(define (ssyntax? x)
  (and (symbol? x)
       ;(not (or (eq? x '+) (eq? x '++) (eq? x '_)))
       (let ((name (symbol->string x)))
         (has-ssyntax-char? name (- (string-length name) 1)))))

(define (chars->value chars) (read-from-string (list->string chars)))
(define (insym? char sym) (member char (symbol->chars sym)))

(define (expand-compose sym)
  (let ((elts (map (lambda (tok)
                     (if (eqv? (car tok) #\~)
                         (if (null? (cdr tok))
                             (->orig-box 'no)
                             (list (->orig-box 'complement) (chars->value (cdr tok))))
                         (chars->value tok)))
                   (tokens (lambda (c) (eqv? c #\:))
                           (symbol->chars sym)
                           null
                           null
                           #f))))
    (if (null? (cdr elts))
        (car elts)
        (cons (->orig-box 'compose) elts))))

(define (build-sexpr toks orig)
  (cond ((null? toks)
          (->orig-box 'get))
        ((null? (cdr toks))
          (chars->value (car toks)))
        (else
          (list (build-sexpr (cddr toks) orig)
                (if (eqv? (cadr toks) #\!)
                    (list (->orig-box 'quote) (chars->value (car toks)))
                    (if (or (eqv? (car toks) #\.) (eqv? (car toks) #\!))
                        (error "bad ssyntax" orig)
                        (chars->value (car toks))))))))

(define (expand-and sym)
  (let ((elts (map chars->value
                   (tokens (lambda (c) (eqv? c #\&))
                           (symbol->chars sym)
                           null
                           null
                           #f))))
    (if (null? (cdr elts))
        (car elts)
        (cons (->orig-box 'andf) elts))))

(define (expand-sexpr sym)
  (build-sexpr (reverse (tokens (lambda (c) (or (eqv? c #\.) (eqv? c #\!)))
                                (symbol->chars sym)
                                null
                                null
                                #t))
               sym))

;; TODO: better definition of ssexpand
(define (ssexpand sym)
  (cond ((or (insym? #\: sym) (insym? #\~ sym))  (expand-compose sym))
        ((or (insym? #\. sym) (insym? #\! sym))  (expand-sexpr sym))
        ((insym? #\& sym)                        (expand-and sym))
        (else                                    (error "unknown ssyntax" sym))))

;=============================================================================
;  Stuff exposed to Arc
;=============================================================================
(define (init)
  ;===========================================================================
  ;  Arc/Nu primitives
  ;===========================================================================
  (->orig-box 'fn)
  (->orig-box 'quote)
  (->orig-box 'and)
  (->orig-box 'no)
  (->orig-box 'complement)
  (->orig-box 'compose)
  (->orig-box 'get)
  (->orig-box 'andf)
  (->orig-box 'string)

  (assign sym->box #:sig (x) ->box)

  (mac if args
    (cons nocompile (ac-if args)))

  (mac fn (parms . body)
    (cons nocompile (ac-fn parms body)))

  (mac quasiquote (x)
    (qq-expand x))

  (mac square-brackets body
    `(,(->orig-box 'fn) (_) ,body))

  (mac % args
    (cons nocompile
      `(begin ,@args)))

  (mac assign (x . rest)
    (cons nocompile
      `(begin ,@(pairfn ac-assign (cons x rest)))))

  (mac var (x . rest)
    (cons nocompile
      `(begin ,@(pairfn ac-var (cons x rest)))))

  (mac get-setter (x get set)
    (let ((x (->box x)))
      (cons nocompile
        `(begin (,set-box-get! ,x ,(ac get))
                (,set-box-set! ,x ,(ac set))
                ,(ac nil)))))

  (mac quote (x)
    (let ((x (dottedrec sym->nil x)))
      (cons nocompile `(quote ,x))))

  (mac w/exclude (x . body)
    (w/-maker body (lambda (old new)
      (for ((x x))
        (set! new (w/exclude old new x)))
      new)))

  (mac w/include (x . body)
    (w/-maker body (lambda (old new)
      (for ((x x))
        (set! old (hash-set old x (hash-ref new x))))
      old)))

  (mac w/rename (x . body)
    (w/-maker body (lambda (old new)
      (for ((x (->pair x)))
        (set! new (hash-set new (cadr x) (hash-ref new (car x))))
        (set! new (w/exclude old new (car x))))
      new)))

  (mac w/prefix (x . body)
    (w/-maker body (lambda (old new)
      (hash-diff old new (lambda (key val)
        (set! old (hash-set old
                    (string->symbol (string-append (->string x) ; TODO ?
                                                   (->string key)))
                    val))))
      old)))

  ; TODO: re/import should probably eval its args
  (mac import args
    (for ((x args))
      (ac-load x))
    nil)

  (mac reimport args
    (for ((x args))
      (ac-load x #t))
    nil)

  ;(def %port-next-location)

  ;(assign ref #:sig (x k (o d)) ref)
  ;(def %symbol-global)

  ;(assign close1 #:sig (x) close1)

  (def sym->filename (x)
    (let ((x (->safe-box x)))
      (if x
          (box-file x)
          nil)))

  (def call-w/stderr (port thunk)
    (parameterize ((current-error-port port)) (thunk)))

  ;===========================================================================
  ;  Arc 3.1 primitives (97 total)
  ;===========================================================================
  ; Types
  ;; TODO: a better argument name than typ
  (def annotate (typ rep)
    (if (is? (type rep) typ)
        rep
        (tagged typ rep)))

  (assign type #:sig (x) type)

  (def rep (x)
    (if (tagged? x)
        (tagged-rep x)
        x))

  (assign coerce #:sig (x to (o base 10)) coerce)

  ; Conses
  (assign nil nil)
  (assign cons #:sig (x y) cons)
  (assign car  #:sig (x)   ac-car)
  (assign cdr  #:sig (x)   ac-cdr)

  (def scar (p x)
    (cond ((pair? p)    (unsafe-set-mcar! p x))
          ((string? x)  (string-set! p 0 x))
          (else         (raise-type-error 'scar "cons" p)))
    x)

  (def scdr (p x)
    (cond ((pair? p)    (unsafe-set-mcdr! p x))
          ((string? x)  (error "can't set cdr of a string" x))
          (else         (raise-type-error 'scdr "cons" p)))
    x)

  ; Comparison
  (assign is #:sig args (make-pairwise is?))
  (assign <  #:sig args (make-pairwise (make-comparer < string<? char<?)))
  (assign >  #:sig args (make-pairwise (make-comparer > string>? char>?)))

  ; Numbers
  (assign -     #:sig args      -)
  (assign *     #:sig args      *)
  (assign /     #:sig args      /)
  (assign sin   #:sig (x)       sin)
  (assign cos   #:sig (x)       cos)
  (assign tan   #:sig (x)       tan)
  (assign asin  #:sig (x)       asin)
  (assign acos  #:sig (x)       acos)
  (assign atan  #:sig (x (o y)) atan)
  (assign log   #:sig (x)       log) ;; logarithm
  (assign mod   #:sig (x y)     modulo)
  (assign expt  #:sig (x y)     expt)
  (assign sqrt  #:sig (x)       sqrt)

  (def exact (x) (tnil (exact-integer? x))) ;; TODO: bad name

  (assign + #:sig args (make-reduce ac-+ 0))

  (def trunc (x)
    (inexact->exact (truncate x)))

  ; Streams
  (assign sread     #:sig (p eof)                sread)
  (assign outstring #:sig ((o name 'string))     open-output-string)
  (assign instring  #:sig (str (o name 'string)) open-input-string)
  (assign inside    #:sig (out)                  get-output-string)
  (assign stdin     #:sig ((o in))               current-input-port)  ; should be a vars
  (assign stdout    #:sig ((o out))              current-output-port)
  (assign stderr    #:sig ((o err))              current-error-port)
  (assign readc     #:sig ((o in (stdin)))       (make-read read-char))
  (assign readb     #:sig ((o in (stdin)))       (make-read read-byte))
  (assign peekc     #:sig ((o in (stdin)))       (make-read peek-char))
  (assign writec    #:sig (c (o out (stdout)))   (make-write write-char))
  (assign writeb    #:sig (c (o out (stdout)))   (make-write write-byte))
  (assign write     #:sig (x (o out (stdout)))   (make-print write))
  (assign disp      #:sig (x (o out (stdout)))   (make-print display))

  (def close args
    (for ((x args)) (close1 x))
    (for ((x args)) (try-custodian x)) ;; free any custodian
    nil)

  (def infile (path (mode 'binary))
        #:sig (path (o mode 'binary))
    (open-input-file path #:mode mode))

  (def outfile (path (mode 'truncate))
         #:sig (path (o mode 'truncate))
    (open-output-file path #:mode 'text #:exists mode))

  (def call-w/stdin (port thunk)
    (parameterize ((current-input-port port)) (thunk)))

  (def call-w/stdout (port thunk)
    (parameterize ((current-output-port port)) (thunk)))

  (def open-socket (num)
    (tcp-listen num 50 #t))

  (def socket-accept (s)
    (let ((oc  (current-custodian))
          (nc  (make-custodian)))
      (current-custodian nc)
      (call-with-values
        (lambda () (tcp-accept s))
        (lambda (in out)
          (let ((in1 (make-limited-input-port in 100000 #t)))
            (current-custodian oc)
            (associate-custodian nc in1 out)
            (list in1
                  out
                  (let-values (((us them) (tcp-addresses out))) them)))))))

  ;; TODO: should pipe call ((caddddr x) 'wait)?
  (def pipe-from (cmd)
           ;; TODO: destructuring
    (let* ((x   (process/ports #f #f (current-error-port) cmd))
           (in  (car x))
           (out (cadr x)))
      ;; Racket docs say I need to close all 3 ports explicitly,
      ;; but the err port doesn't need to be closed, because it's
      ;; redirected to stderr
      (close-output-port out)
      in))

  (def client-ip (port)
    (let-values (((x y) (tcp-addresses port))) y))

  ; Added because Mzscheme buffers output.  Not a permanent part of Arc.
  ; Only need to use when declare explicit-flush optimization.
  (def flushout ()
    (flush-output)
    t)

  (def force-close args
    (for ((p args))
      ;; TODO: force-close1
      (when (not (try-custodian p))
        (close1 p)))
    nil)

  ; OS
  ;; allow Arc to give up root privileges after it calls open-socket.
  ;; thanks, Eli!
  (assign setuid #:sig (i) (get-ffi-obj 'setuid #f (_fun _int -> _int)))

  ;: TODO: need to use a better seed (Arc 3.1???)
  (assign rand                         #:sig ((o n) (o gen)) random)
  (assign quit                         #:sig ((o n 0))       exit)
  (assign msec                         #:sig ()              current-milliseconds)
  (assign current-gc-milliseconds      #:sig ()              current-gc-milliseconds)
  (assign current-process-milliseconds #:sig (x)             current-process-milliseconds)
  (assign memory                       #:sig ((o custodian)) current-memory-use)
  (assign seconds                      #:sig ()              current-seconds)

  ;; Will system "execute" a half-finished string if thread killed in the
  ;; middle of generating it?
  (def system (command) (system command) nil)
  (def rmfile (path)    (delete-file path) nil)

  (def file-exists (x) (tnil (file-exists? x)))
  (def dir-exists  (x) (tnil (directory-exists? x)))

  ;; TODO: better dir
  (def dir (name)
    (map path->string (directory-list name)))

  (def mvfile (old new (flag t))
        #:sig (old new (o flag t))
    (rename-file-or-directory old new (true? flag))
    nil)

  (def timedate ((sec (current-seconds)))
          #:sig ((o sec (seconds)))
    (let ((d (seconds->date sec)))
      (list (date-second d)
            (date-minute d)
            (date-hour d)
            (date-day d)
            (date-month d)
            (date-year d))))

  ; Threads
  (assign new-thread     #:sig (thunk) thread)
  (assign kill-thread    #:sig (x)     kill-thread)
  (assign break-thread   #:sig (x)     break-thread)
  (assign current-thread #:sig ()      current-thread)

  (def sleep args #:sig ((o sec 0)) (apply sleep args) nil)

  (def dead (x) (tnil (thread-dead? x)))

  ;; TODO: make this better
  (def atomic-invoke (f)
    (if (thread-cell-ref sema-cell)
        ;; TODO: why are these call...?
        (call f)
        (begin (thread-cell-set! sema-cell #t)
               (dynamic-wind (lambda () #t)
                             (lambda ()
                               (call-with-semaphore
                                 the-sema
                                 (lambda () (call f))))
                             (lambda ()
                               (thread-cell-set! sema-cell #f))))))

  ; Continuations
  (assign ccc #:sig (f (o prompt)) call-with-current-continuation)

  (def protect (during after)
    (dynamic-wind (lambda () #t) during after))

  ; Tables
  (def table ((init nil))
       #:sig ((o init))
    (let ((h (make-hash)))
      (when (true? init)
        (init h))
      h))

  (def maptable (fn table)
    (hash-for-each table fn) ; arg is (fn (key value) ...)
    table)

  ; Errors
  (assign details #:sig (e)        exn-message)
  (assign err     #:sig (x . rest) error) ; raise-user-error

  (def on-err (errfn f)
    (with-handlers ((exn:fail? errfn)) (f))
    ;; TODO: why does Arc 3.1 implement it like this?
    #|((call-with-current-continuation
       (lambda (k)
         (lambda ()
           (with-handlers ((exn:fail? (lambda (e)
                                        (k (lambda () (errfn e))))))
                          (f))))))|#
    )

  ; Symbols
  (assign macex1 #:sig (e) macex1)
  (assign macex  #:sig (e) macex)

  (def ssyntax (x) (tnil (ssyntax? x)))

  (def ssexpand (x)
    (if (symbol? x) (ssexpand x) x))

  (def bound (x)
    (lookup x
      (lambda (_) t)
      (lambda () nil)))

  (def uniq ((name 'g) (num nil))
      #:sig ((o name 'g) (o num))
    (when (false? num)
      (set! num (uniq-counter))
      (uniq-counter (+ (uniq-counter) 1)))
    (string->uninterned-symbol
      (string-append (coerce name 'string)
                     (coerce num  'string))))

  ; Other
  (assign t t)
  (assign sig sig)
  (assign newstring #:sig (n (o c #\nul)) make-string)

  ;; Later may want to have multiple indices.
  (def sref (x val key)
    (cond ((hash? x)    (if (false? val)
                            (hash-remove! x key)
                            (hash-set! x key val)))
          ((string? x)  (string-set! x key val))
          ((pair? x)    (unsafe-set-mcar! (list-tail x key) val))
          (else         (error "can't set reference " x key val)))
    val)

  (def len (x)
    (cond ((string? x)  (string-length x))
          ((hash? x)    (hash-count x))
          (else         (length x))))

  (def eval (expr)
    (eval (ac expr)))

  (def declare (key val)
    (let ((flag (true? val)))
      (case key
        ((atstrings)      (set! atstrings      flag))
        ((direct-calls)   (set! direct-calls   flag))
        ((inline-calls)   (set! inline-calls   flag))
        ((explicit-flush) (set! explicit-flush flag))
        (else             (warn "invalid declare mode " key)))
      val))

  (def apply (f . args)
    ; TODO; is this inefficient?
    (apply apply call f args)))
