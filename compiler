#lang racket/base
;; Arc/Nu Compiler -- Manifest Destiny
;; http://www.youtube.com/watch?v=qXp3qjeM0e4

;; TODO: look for uses of null? and replace them with empty-stream? as needed
;; TODO: use Racket's custom write/display stuff, so that printing infinite lists works
;; TODO: keyword args ???

(provide (all-defined-out))

(require racket/unsafe/ops)
(require racket/path)
(require racket/port)
(require racket/system)
(require racket/tcp)

;; Layer 1
(define atstrings        (make-parameter #f))
(define direct-calls     (make-parameter #f))
;(define inline-calls     #f)
(define explicit-flush   (make-parameter #f))

(define nocompile        (gensym)) ; if in the car the expression won't be compiled
(define sig              (make-hasheq))
(define names            (make-hasheq))
(define t                't)
(define nil              null)

(define filename         (make-parameter #f))

(define debug?           (make-parameter #f))
(define hygienic-macros? (make-parameter #f))
(define hyper-static?    (make-parameter #f))

(define import-cache     (make-parameter #f))
(define import-dirs      (make-parameter null))

(define local?           (make-parameter #f))
(define locals           (make-parameter (hasheq)))

(define orig-globals     (make-parameter #f))
(define exported-globals (make-parameter #f))
(define globals          (make-parameter (hasheq)))

(define ac-fn-let*       (make-parameter #f))
(define uniq-counter     (make-parameter 1))

; make sure only one thread at a time executes anything
; inside an atomic-invoke. atomic-invoke is allowed to
; nest within a thread; the thread-cell keeps track of
; whether this thread already holds the lock.
(define the-sema  (make-semaphore 1))
(define sema-cell (make-thread-cell #f))

; there are two ways to close a TCP output port.
; (close o) waits for output to drain, then closes UNIX descriptor.
; (force-close o) discards buffered output, then closes UNIX desc.
; web servers need the latter to get rid of connections to
; clients that are not reading data.
; mzscheme close-output-port doesn't work (just raises an error)
; if there is buffered output for a non-responsive socket.
; must use custodian-shutdown-all instead.
(define custodians (make-hash))

(struct box (uniq file [get #:auto #:mutable]
                       [set #:auto #:mutable])
  #:constructor-name make-box
  #:guard (lambda (uniq file _)
            (if (symbol-interned? uniq)
                (values (string->uninterned-symbol (symbol->string uniq)) file)
                (values uniq file)))
  #:methods gen:custom-write
    [(define (write-proc x port mode)
       (display "#<box:" port)
       (display (box-uniq x) port)
       (display ">" port))])

(struct tagged (type rep)
  ;; TODO: make mutable later, maybe
  ;#:mutable
  #:methods gen:custom-write
    [(define (write-proc x port mode)
       (begin (display "#(tagged " port)
              (display (tagged-type x) port)
              (display " " port)
              (display (tagged-rep x) port)
              (display ")" port)))])

; TODO: is there seriously no built-in way to do this?
(define (->pair x)
  (cond ((null? x)
          x)
        ((null? (cdr x))
          (list (list (car x))))
        (else
          (cons (list (car x) (cadr x))
                (->pair (cddr x))))))

(define (hash-if-key hash key yes no)
  (if (hash-has-key? hash key)
      (yes hash (hash-ref hash key))
      (no hash)))

(define (hash-merge to from)
  (hash-for-each from
    (lambda (key val)
      (set! to (hash-set to key val))))
  to)

(define (hash-merge! to from)
  (hash-for-each from
    (lambda (key val)
      (hash-set! to key val))))

(define (hash-different? old key val)
  (or (not (hash-has-key? old key))
      (not (eq? (hash-ref old key) val))))

(define (hash-diff old new f)
  (hash-for-each new
    (lambda (key val)
      (when (hash-different? old key val)
        (f key val)))))

(define (fraction? x)
  (and (number? x)
       (exact? x)
       (not (integer? x))))

(define (iround x) (inexact->exact (round x)))

(define (is? x y)
  (or (eqv? x y)
      (and (string? x) (string? y) (string=? x y))
      ;; TODO: why is this here in Arc 3.1?
      ;(and (false? x) (false? y))
      ))

;; generic comparison
(define (make-comparer a b c)
  (lambda (x y)
          ;; TODO: better ordering for speed
    (cond ((number? x)  (a x y))
          ((string? x)  (b x y))
          ((char? x)    (c x y))
          ((symbol? x)  (b (symbol->string x)
                           (symbol->string y)))
          (else         (a x y)))))

;; based on Arc's reduce. Can't use foldl because it doesn't work well with
;; multiple types (e.g. +-2)
(define (reduce f xs)
  (if (null? (cdr xs))
      (car xs) ;(f (car xs))
      (reduce f (cons (f (car xs) (cadr xs)) (cddr xs)))))

; First unescaped @ in s, if any.  Escape by doubling.
(define (atpos s i)
         ;; TODO: shouldn't this use = ?
  (cond ((eqv? i (string-length s))
          #f)
        ((eqv? (string-ref s i) #\@)
          (if (and (< (+ i 1) (string-length s))
                   (not (eqv? (string-ref s (+ i 1)) #\@)))
              i
              (atpos s (+ i 2))))
        (else
          (atpos s (+ i 1)))))

(define (unescape-ats s)
  (list->string (let self ((cs (string->list s)))
                  (cond ((null? cs)
                          cs)
                        ((and (eqv? (car cs) #\@)
                              (not (null? (cdr cs)))
                              (eqv? (cadr cs) #\@))
                          (self (cdr cs)))
                        (else
                          (cons (car cs) (self (cdr cs))))))))

(define (dottedrec f xs)
  (let self ((xs xs))
    (if (pair? xs)
        (cons (f (self (car xs)))
              (self (cdr xs)))
        (f xs))))

;; the next two are optimizations, except work for macros.
(define (de-compose fns args)
        ;; TODO: is this needed anywhere in Arc or can I remove it...?
  (if ;(null? fns)       `((fn vals (car vals)) ,@args)
      (null? (cdr fns)) (cons (car fns) args)
                        (list (car fns) (de-compose (cdr fns) args))))

(define (de-andf f args)
  (let ((gs (map (lambda (x) (gensym)) args)))
    `((,(->orig-box 'fn) ,gs
        (,(->orig-box 'and) ,@(map (lambda (f) (cons f gs))
                                   (cdr f))))
      ,@args)))

#|(define (keyword-args? args)
  (let self ((x args))
    (if (pair? x)
        (if (keyword? (car x))
            #t
            (self (cdr x)))
        #f)))|#

(define (ac-car x)
  (cond ((pair? x)
          (unsafe-car x))
        ((null? x)
          x)
        (else
          (raise-type-error 'car "cons" x))))

(define (ac-cdr x)
  (cond ((pair? x)
          (unsafe-cdr x))
        ((null? x)
          x)
        (else
          (raise-type-error 'cdr "cons" x))))

;; Layer 2
;; convert Racket booleans to Arc booleans
(define (tnil x) (if x t nil))

(define (sym->nil x)
  (if (eq? x 'nil) nil x))

;; definition of falseness for Arc's if
(define (false? x)
  (or (eq? x nil)
      (eq? x #f)))

(define (type x)
        ;; TODO: better ordering for speed
  (cond ((tagged? x)         (tagged-type x))
        ((namespace? x)      'namespace)
        ((pair? x)           'cons)
        ;((stream? x)         'stream) ;; TODO: not sure about this
        ((symbol? x)         'sym) ;; TODO: a type for boxes? overload 'sym?
        ((null? x)           'sym) ; (type nil) -> sym
        ((procedure? x)      'fn)
        ((char? x)           'char)
        ((string? x)         'string)
        ((exact-integer? x)  'int)
        ((number? x)         'num)     ; unsure about this
        ((hash? x)           'table)
        ((output-port? x)    'output)
        ((input-port? x)     'input)
        ((tcp-listener? x)   'socket)
        ((exn? x)            'exception)
        ((thread? x)         'thread)
                             ;(err "type: unknown type" x)
                             ;; TODO: not sure about this, but seems okay
        (else                nil)))

;; (pairwise pred '(a b c d)) =>
;;   (and (pred a b) (pred b c) (pred c d))
;; pred returns #t/#f, pairwise returns t/nil
(define (pairwise pred lst)
        ; TODO: does this need to check the cdr?
  (cond ((null? (cdr lst))
          t)
        ((pred (car lst) (cadr lst))
          (pairwise pred (cdr lst)))
        (else nil)))

(define (make-reduce f init)
  (case-lambda
    ((x y) (f x y))
    ((x)   x)
    (()    init)
    (args  (reduce f args))))

;; Non-fn constants in functional position are valuable real estate, so
;; should figure out the best way to exploit it.  What could (1 foo) or
;; ('a foo) mean?  Maybe it should mean currying.
;;
;; For now the way to make the default val of a hash table be other than
;; nil is to supply the val when doing the lookup.  Later may also let
;; defaults be supplied as an arg to table.  To implement this, need: an
;; eq table within scheme mapping tables to defaults, and to adapt the
;; code in arc.arc that reads and writes tables to read and write their
;; default vals with them.  To make compatible with existing written tables,
;; just use an atom or 3-elt list to keep the default.
;;
;; experiment: means e.g. [1] is a constant fn
;;       ((or (number? fn) (symbol? fn)) fn)
;; another possibility: constant in functional pos means it gets
;; passed to the first arg, i.e. ('kids item) means (item 'kids).
(define ref
  (case-lambda
    ((x k)    (cond ((hash? x)    (hash-ref x k nil))
                    ((string? x)  (string-ref x k))
                    ((pair? x)    (list-ref x k))
                    (else         (error "function call on inappropriate object" x k))))
    ((x k d)  (if   (hash? x)     (hash-ref x k d)
                                  (error "function call on inappropriate object" x k d)))
    (args     (apply error "function call on inappropriate object" args))))

;; All of this is for atstrings, not needed for normal strings at all
(define (codestring s)
  (let ((i (atpos s 0)))
    (if i  (cons (substring s 0 i)
                 (let* ((rest (substring s (+ i 1)))
                        (in   (open-input-string rest))
                        (expr (read in))
                        (i2   (let-values (((x y z) (port-next-location in))) z)))
                   (close-input-port in)
                   (cons expr (codestring (substring rest (- i2 1))))))
           (list s))))

;; Layer 3
(define (true? x)
  (not (false? x)))

;; TODO: list + table of types for coerce
(define (coerce x to (base 10))
  (cond ((tagged? x)         (error "can't coerce annotated object"))
        ((is? to (type x))   x)
        ((symbol? x)         (case to
                              ((string)  (symbol->string x))
                              (else      (error "can't coerce" x to))))
        ((pair? x)           (case to
                              ((string)  (apply string-append
                                                (map (lambda (y) (coerce y 'string))
                                                     x)))
                              (else      (error "can't coerce" x to))))
        ;(eq? x nil)
        ((null? x)           (case to
                              ((string)  "")
                              (else      (error "can't coerce" x to))))
        ((char? x)           (case to
                              ((int)     (char->integer x))
                              ((string)  (string x))
                              ((sym)     (string->symbol (string x)))
                              (else      (error "can't coerce" x to))))
        ((exact-integer? x)  (case to
                              ((num)     x)
                              ((char)    (integer->char x))
                              ((string)  (number->string x base))
                              (else      (error "can't coerce" x to))))
        ((number? x)         (case to
                              ((int)     (iround x))
                              ((char)    (integer->char (iround x)))
                              ((string)  (number->string x base))
                              (else      (error "can't coerce" x to))))
        ((string? x)         (case to
                              ((sym)     (string->symbol x))
                              ((cons)    (string->list x))
                              ((num)     (or (string->number x base)
                                             (error "can't coerce" x to)))
                              ((int)     (let ((n (string->number x base)))
                                           (if n  (iround n)
                                                  (error "can't coerce" x to))))
                              (else      (error "can't coerce" x to))))
        (else                (error "can't coerce" x to))))

(define (make-pairwise f)
  (case-lambda
    ((x y) (tnil (f x y)))
    ((x)   t)
    (()    t)
    (args  (pairwise f args))))

;; call a function or perform an array ref, hash ref, etc.
(define call
  ;; uses case-lambda for ridiculous speed: now using call for *all* function
  ;; calls is just as fast as using the funcall functions, and unlike
  ;; funcall, this hardcodes up to 6 arguments rather than only 4
  ;;
  ;; I could go higher but it'd be kinda pointless and would just make the
  ;; definition of call even bigger than it already is
  (case-lambda
    ((x)              (if (procedure? x)
                          (x)
                          (ref x)))
    ((x a)            (if (procedure? x)
                          (x a)
                          (ref x a)))
    ((x a b)          (if (procedure? x)
                          (x a b)
                          (ref x a b)))
    ((x a b c)        (if (procedure? x)
                          (x a b c)
                          (ref x a b c)))
    ((x a b c d)      (if (procedure? x)
                          (x a b c d)
                          (ref x a b c d)))
    ((x a b c d e)    (if (procedure? x)
                          (x a b c d e)
                          (ref x a b c d e)))
    ((x a b c d e f)  (if (procedure? x)
                          (x a b c d e f)
                          (ref x a b c d e f)))
    ((x . args)       ;(prn "warning: called with 7+ arguments:" x args)
                      (if (procedure? x)
                          (apply x args)
                          (apply ref x args)))))

;; Layer 4
(define (macro? x yes no)
  (let ((b (lookup x
             (lambda (x) x)
             (lambda ()  x))))
    (if (and (tagged? b)
             (eq? (tagged-type b) 'mac))
        (yes (tagged-rep b))
        (no))))

;; generic +: strings, lists, numbers.
;; return val has same type as first argument.
(define (ac-+ x y)
        ;; TODO: better ordering for speed
  (cond ((number? x)  (+ x y))
        ((string? x)  (string-append x (coerce y 'string)))
        ((list? x)    (append x y))
        ;; TODO: check the behavior of Arc 3.1 for (+ "foo" #\a) and (+ #\a "foo")
        ((char? x)    (string-append (string x) (coerce y 'string)))
        (else         (+ x y))
                      ;(err "can't + " x " with " y)
                      ))

;; Layer 5
(define (macex1 e)
  (if (pair? e)
      (macro? (car e)
        (lambda (x)
          (let ((x (apply x (cdr e))))
            (if (eq? (car x) nocompile)
                e
                x)))
        (lambda () e))
      e))

(define (fn-call-normal x args)
  (let ((r (ac x)))
            ;; optimization for (#<fn> ...) and ((fn ...) ...)
    (if (or (procedure? r)
            (and (pair? r)
                 (eq? (car r) 'lambda))
            ;; needed because call doesn't accept keyword args
            ;(keyword-args? args)
            )
        (cons r (ac-all args))
        (list* call r (ac-all args)))))

(define (fn-call x args)
  (lookup x
    (lambda (f)
            ;; inserts the actual value for things in functional position, so
            ;; (+ 1 2) compiles into (#<fn:+> 1 2)
            ;;
            ;; this is much faster than direct-calls but it's even more strict:
            ;; if you redefine any global, even functions, those changes aren't
            ;; retroactive: they affect new code, but not old code
      (cond #|(inline-calls
              (if (procedure? f)
                  (cons f (ac-all args))
                  (list* ref f (ac-all args))))|#
            ;; (foo bar) where foo is a global variable bound to a procedure.
            ;; this breaks if you redefine foo to be a non-fn (like a hash table)
            ;; but as long as you don't redefine anything, it's faster
            ((and (direct-calls)
                  (procedure? f))
              (cons (ac x) (ac-all args)))
            (else
              (fn-call-normal x args))))
    (lambda ()
      (fn-call-normal x args))))

(define (mac-call x y)
  (macro? x
    (lambda (x) (ac (apply x y)))
    (lambda ()  (fn-call x y))))

(define (ac-call f args)
  (when (ssyntax? f)
    (set! f (ssexpand f)))
  (if (pair? f)
      (let ((c (car f)))
        (macro? c
          (lambda (_)
            (cond ((orig-box? c 'compose)
                    (ac (de-compose (cdr f) args)))
                  ((orig-box? c 'complement)
                    (ac (list (->orig-box 'no) (cons (cadr f) args))))
                  ((orig-box? c 'andf)
                    (ac (de-andf f args)))
                  (else
                    (mac-call f args))))
          (lambda ()
            (mac-call f args))))
      (mac-call f args)))

(define (ac-string s)
  (if (atstrings)
      (if (atpos s 0)
          (ac (cons (->orig-box 'string)
                    (map (lambda (x)
                           (if (string? x)
                               (unescape-ats x)
                               x))
                         (codestring s))))
          (unescape-ats s))
      ;; This is for normal strings
      (string-copy s))) ; avoid immutable strings

(define (ac x)
  (cond ((symbol? x)
          (if (ssyntax? x)
              (ac (ssexpand x))
              (ac (->box x))))
        ((box? x)
          (if (box-get x)
              (ac ((box-get x)))
              (box-uniq x)))
        ((pair? x)
          (if (eq? (car x) nocompile)
              (cdr x)
              (ac-call (car x) (cdr x))))
        ((null? x)
          ;; this causes it to return null
          ;null
          `(quote ,x))
        ((string? x)
          (ac-string x))
        (else x)))

(define (ac-all x)
  (let self ((x x))
    (if (pair? x)
        (cons (ac (car x))
              (self (cdr x)))
        x)))

(define (pairfn f x)
  (if (null? (cdr x))
      (cons (f (car x) null)
            ;; this is so the assign form returns the value
            (list (ac (car x))))
               ;; TODO: why does Arc 3.1 call macex here?
      (cons (f (car x) (cadr x))
            (if (null? (cddr x))
                (list (ac (car x)))
                (pairfn f (cddr x))))))

;; Layer 6
(define (macex e)
  (let ((v (macex1 e)))
    (if (eq? v e)
        v
        (macex v))))

; qq-expand takes an Arc list containing a quasiquotation expression
; (the x in `x), and returns an Arc list containing Arc code.  The Arc
; code, when evaled by Arc, will construct an Arc list, the
; expansion of the quasiquotation expression.
;
; This implementation is a modification of Alan Bawden's quasiquotation
; expansion algorithm from "Quasiquotation in Lisp"
; http://repository.readscheme.org/ftp/papers/pepm99/bawden.pdf
(define (qq-atom x)
  (if (symbol? x)
      (if (hygienic-macros?)
          (->box x)
          (list (->orig-box 'quote) x))
      x))

(define (qq-expand x)
  (if (pair? x)
      (let ((c (car x)))
        (cond ((orig-box? c 'unquote)
                (cadr x))
              ((orig-box? c 'unquote-splicing)
                (error ",@ cannot be used immediately after `"))
              ((orig-box? c 'quasiquote)
                (qq-expand (qq-expand (cadr x))))
              (else
                (qq-expand-pair x))))
      (qq-atom x)))

; TODO: probably shouldn't special-case quote... figure out another way?
(define (qq-expand-quote c)
  (list cons (qq-expand-pair (car c))
             (parameterize ((hygienic-macros? #f))
               (qq-expand-pair (cdr c)))))

(define (qq-expand-pair x)
  (if (pair? x)
      (let ((c (car x)))
              ;; TODO handle 'quote here too ?
        (cond ((and (orig-box? c 'unquote)
                    (null? (cddr x)))
                (cadr x))
              ((and (orig-box? c 'unquote-splicing)
                    (null? (cddr x)))
                (error "cannot use ,@ after ."))
              ((pair? c)
                (cond ((orig-box? (car c) 'quote)
                        (list cons (qq-expand-quote c)
                                   (qq-expand-pair (cdr x))))
                      ((orig-box? (car c) 'unquote)
                        (list cons (cadr c)
                                   (qq-expand-pair (cdr x))))
                      ((orig-box? (car c) 'unquote-splicing)
                        (if (null? (cdr x))
                            (cadr c)
                            (list append (cadr c)
                                         (qq-expand-pair (cdr x)))))
                      ((orig-box? (car c) 'quasiquote)
                        (list cons (qq-expand-pair (qq-expand (cadr c)))
                                   (qq-expand-pair (cdr x))))
                     (else
                       ;; TODO: code duplication
                       (list cons (qq-expand-pair c)
                                  (qq-expand-pair (cdr x))))))
              (else
                (list cons (qq-expand-pair c)
                           (qq-expand-pair (cdr x))))))
      (qq-atom x)))

; (if)           -> nil
; (if x)         -> x
; (if t a ...)   -> a
; (if nil a b)   -> b
; (if nil a b c) -> (if b c)
(define (ac-if args)
        ;; TODO: maybe simplify this a little, like by using ac-cdr
  (cond ((null? args)
          (ac nil)) ; TODO: hardcodes null, rather than using the variable 'nil
        ((null? (cdr args))
          (ac (car args)))
        (else
          ;; TODO: fix this if I expose true? to Arc
          `(if (,true? ,(ac (car args)))
               ,(ac (cadr args))
               ,(ac-if (cddr args))))))

(define (w/init dir path lang f #:debug [debug #f])
  ;; This is so that it's possible to retrieve the column/line of an input port
  ; (port-count-lines-enabled #t)
  (parameterize ((current-readtable arc-readtable)
                 (filename (path->string path))
                 (debug? debug)
                 (globals (globals))
                 (import-cache (make-hash))
                 (import-dirs (list* (path->string (current-directory)) ; TODO
                                     (path->string (build-path dir "lib"))
                                     (import-dirs)))
                 (orig-globals (make-hasheq))
                 (compile-allow-set!-undefined #t))
    (init)
    (load (build-path dir "lang" lang "main"))
    ;; These files have Arc/Nu's dir prefixed to them
    ;; and are automatically loaded when Arc/Nu
    ;; starts up.
    #|(for ((x (list "02 arc"
                   "03 utils"
                   "04 paths"
                   "lib/strings"
                   "lib/re")))
      (ac-load (build-path dir x)))|#
    (f ac-load)))

;=============================================================================
;  import
;=============================================================================
; sread = scheme read. eventually replace by writing read
(define (sread p eof)
  (let ((expr (read p)))
    (if (eof-object? expr)
        eof
        (dottedrec sym->nil expr)))) ; TODO: why does this call sym->nil?

; TODO: use coerce?
(define (->string x)
  (cond ((symbol? x)
          (symbol->string x))
        ((path? x)
          (path->string x))
        ((string? x)
          x)
        (else #f)))

(define (exists? p dir file none)
  (cond ((file-exists? p)
          (file p))
        ((directory-exists? p)
          (dir p))
        (else
          (none))))

(define (abspath x y)
  (path->string
    (normal-case-path
      (simplify-path
        (resolve-path
          (path->complete-path (expand-user-path x) y))))))

(define (find-filename p dir file)
  (let self ((x (import-dirs)))
    (if (pair? x)
        (let ((p (abspath p (car x))))
          (exists? p dir file
            (lambda ()
                       ; TODO: don't hardcode .arc?
              (exists? (string-append p ".arc") dir file
                (lambda ()
                  (self (cdr x)))))))
        (error (string-append "file \"" p "\" was not found")))))

(define (load-file p)
  (parameterize ((filename p)
                 (import-dirs (cons (path-only p) ; TODO: is this good?
                                    (import-dirs)))
                 (hyper-static? (hyper-static?))
                 (hygienic-macros? (hygienic-macros?))
                 (exported-globals (make-hasheq)))
    (let ((old (globals)))
      (call-with-input-file p
        (lambda (x)
          (let self ()
            (let ((x (sread x eof)))
              (if (eof-object? x)
                  ; TODO: how am I going to handle deletions?
                  ;       maybe, rather than using a table, use a list of
                  ;       functions, each of which sets or removes from the
                  ;       global hash table
                  (let ((new (exported-globals)))
                    (globals (hash-merge old new))
                    new)
                  (begin (eval (ac x))
                         (self))))))))))

(define (ac-load p #:reimport [reimport #f]
                   #:export   [export   #f])
  (find-filename (->string p)
    (lambda (p)
      (import-dirs (cons p (import-dirs))))
    (lambda (p)
      (if reimport
          (hash-set! (import-cache) p (load-file p))
          (hash-if-key (import-cache) p
            (lambda (x y)
              (globals (hash-merge (globals) y)))
            (lambda (x)
              (hash-set! x p (load-file p)))))
      (when export
        (let ((hash (exported-globals)))
          (when hash
            (hash-merge! hash (hash-ref (import-cache) p)))))
      (void))))

;=============================================================================
;  fn
;=============================================================================
(define (ac-fn-push x y)
  (ac-fn-let* (cons (list x y) (ac-fn-let*))))

(define (ac-fn-destructure-cdr u args)
  (when (not (null? (cdr args)))
    (ac-fn-push u (list ac-cdr u))))

(define (ac-fn-destructure-car u x args)
  (ac-fn-push x (list ac-car u))
  (ac-fn-destructure-cdr u args))

(define (ac-fn-optional args)
  (let ((args (cddar args)))
    (if (null? args)
        (ac nil)
        (ac (car args)))))

(define (ac-fn-destructure u args)
  (cond ((pair? args)
          (if (pair? (car args))
              (if (eq? (caar args) 'o)
                  (begin (ac-fn-push (box-uniq (make-local-box (cadar args)))
                                     `(if (,pair? ,u)
                                          (,car ,u)
                                          ,(ac-fn-optional args)))
                         (ac-fn-destructure-cdr u args)
                         (ac-fn-destructure u (cdr args)))
                  (let ((v (gensym)))
                    (ac-fn-destructure-car u v args)
                    (ac-fn-destructure v (car args))
                    (ac-fn-destructure u (cdr args))))
              (begin (ac-fn-destructure-car u (box-uniq (make-local-box (car args))) args)
                     (ac-fn-destructure u (cdr args)))))
        ((not (null? args))
          (ac-fn-push (box-uniq (make-local-box args)) u))))

(define (ac-fn-args args)
  (cond ((pair? args)
          (if (pair? (car args))
              (if (eq? (caar args) 'o)
                  (cons (list (box-uniq (make-local-box (cadar args)))
                              (ac-fn-optional args))
                        (ac-fn-args (cdr args)))
                  (let ((u (gensym)))
                    (ac-fn-destructure u (car args))
                    (cons u (ac-fn-args (cdr args)))))
              (cons (box-uniq (make-local-box (car args)))
                    (ac-fn-args (cdr args)))))
        ((null? args)
          args)
        (else
          (box-uniq (make-local-box args)))))

(define (ac-fn parms body)
  (parameterize ((local? #t)
                 (locals (locals))
                 (ac-fn-let* null))
    (let* ((parms (ac-fn-args parms))
           (body  (ac-all (if (null? body)
                              (list nil)
                              body))))
      (if (null? (ac-fn-let*))
          `(lambda ,parms ,@body)
          `(lambda ,parms
             (let* ,(reverse (ac-fn-let*)) ,@body))))))

;=============================================================================
;  I/O
;=============================================================================
(define (read-square-brackets ch port src line col pos)
  `(square-brackets ,@(read/recursive port #\[ #f)))

(define (read-curly-brackets ch port src line col pos)
  `(curly-brackets ,@(read/recursive port #\{ #f)))

#|(define (read-keyword ch port src line col pos)
  (read/recursive (input-port-append #t (open-input-string "#:") port) #f #f))|#

(define arc-readtable
  (make-readtable #f #\[ 'terminating-macro read-square-brackets
                     #\{ 'terminating-macro read-curly-brackets
                     ;#\: 'non-terminating-macro read-keyword
                     ))

;; TODO: not exposed to Arc, but maybe should be
(define (close1 p)
  (cond ((input-port? p)    (close-input-port p))
        ((output-port? p)   (close-output-port p))
        ((tcp-listener? p)  (tcp-close p))
        (else               (error "can't close " p))))

(define (warn . args)
  (display "warning: " (current-error-port))
  (for ((x args))
    (display x (current-error-port)))
  (newline (current-error-port)))

(define (associate-custodian c i o)
  (hash-set! custodians i c)
  (hash-set! custodians o c))

; if a port has a custodian, use it to close the port forcefully.
; also get rid of the reference to the custodian.
; sadly doing this to the input port also kills the output port.
(define (try-custodian p)
  (let ((c (hash-ref custodians p #f)))
    (if c (begin (custodian-shutdown-all c)
                 (hash-remove! custodians p)
                 #t)
          #f)))

(define (read-from-string str)
  (let* ((port  (open-input-string str))
         (val   (read port)))
    (close-input-port port)
    val))

(define (make-write f)
  (lambda (c (out (current-output-port)))
    (f c out)
    c))

(define (make-read f)
  (lambda ((in (current-input-port)) (eof nil))
    (let ((x (f in)))
      (if (eof-object? x) eof x))))

(define (->name x)
  (or (hash-ref names x #f)
      (and (not (tagged? x))
           (object-name x))))

(define (nameit x y)
        ; TODO: code duplication with macro?
  (when (and (tagged? y)
             (eq? (tagged-type y) 'mac))
    ; TODO: this uses symbols rather than boxes
    (hash-set! names y x))
  (if (procedure? y)
      (procedure-rename y x)
      y))

(define (print-w/name x l m r port)
  (let ((x (->name x)))
    (display l port)
    (when x
      (display m port)
      (display x port))
    (display r port)))

(define (print-w/list f x port)
  (display "(" port)
  (let self ((x x))
    (if (pair? x)
        (begin (print f (car x) port)
               (unless (null? (cdr x))
                 (display " " port)
                 (self (cdr x))))
        (begin (display ". " port)
               (print f x port))))
  (display ")" port))

(define (print f x port)
        ;; TODO: should probably use (no x) or whatever
  (cond ((null? x)           (display "nil" port))
        ;; TODO: maybe use isa for pair? and procedure?
        ((pair? x)           (print-w/list f x port))
        #|((keyword? x)        (begin (display ":" port)
                                    (display (keyword->string x) port)))|#
        ((procedure? x)      (print-w/name x "#<fn" ":" ">" port))
        ((eq? (type x) 'mac) (print-w/name x "#<mac" ":" ">" port))
        ((fraction? x)       (f (exact->inexact x) port))
        (else                (f x port)))
  nil)

(define (make-print f)
  (lambda (x (out (current-output-port)))
    (print f x out)
    (unless (explicit-flush) (flush-output out))
    nil))

;=============================================================================
;  Boxes
;=============================================================================
(define-syntax def
  (syntax-rules ()
    ((_ name parms #:sig sig . body)
      (set-sig 'name 'sig (let ((name (lambda parms . body))) name)))
    ((_ name parms . body)
      (set-sig 'name 'parms (let ((name (lambda parms . body))) name)))))

(define-syntax mac
  (syntax-rules ()
    ((_ name parms #:sig sig . body)
      (set-sig 'name 'sig
        (tagged 'mac (let ((name (lambda parms . body))) name))))
    ((_ name parms . body)
      (set-sig 'name 'parms
        (tagged 'mac (let ((name (lambda parms . body))) name))))))

(define-syntax assign
  (syntax-rules ()
    ((_ name #:sig sig value)
      (set-sig 'name 'sig value))
    ((_ name value)
      (set-name 'name value))))

(define (set!-box name a b f)
  (let* ((b  (if (global? a)
                 (list nameit `(quote ,a) (ac b))
                 (ac b)))
         (a  (if (symbol? a)
                 (f a)
                 a)))
    (if (box? a)
        (if (box-set a)
            (ac ((box-set a) (cons nocompile b))) ; TODO: ew, but I don't know of a better way
            `(set! ,(box-uniq a) ,b))
        (error (string-append "first argument to " name " must be a symbol:") a))))

(define (ac-assign a b)
  (set!-box "assign" a b ->box))

(define (ac-var a b)
  (set!-box "var" a b
    (lambda (x)
      (if (hyper-static?)
          (if (local?)
              (let ((x (make-local-box x)))
                (ac-fn-push (box-uniq x) #f)
                x)
              (make-global-box x))
          (->box x)))))

(define (make-global-box x)
  (let ((r (make-box x (filename))))
    (globals (hash-set (globals) x r))
    (let ((hash (exported-globals)))
      (when hash
        (hash-set! hash x r)))
    r))

(define (make-local-box x)
  (let ((r (make-box x (filename))))
    (locals (hash-set (locals) x r))
    r))

; Used to create new global boxes, if they don't already exist
(define (->global-box! x)
  (hash-ref (globals) x
    (lambda ()
      (make-global-box x))))

; Used to convert a symbol to a box
(define (->box x)
  (hash-ref (locals) x
    (lambda ()
      (hash-ref (globals) x
        (lambda ()
          (if (hyper-static?)
              (error "undefined variable:" x)
              (make-global-box x)))))))

; Like ->box except it returns #f if the box doesn't exist
(define (->safe-box x)
  (hash-ref (locals) x
    (lambda ()
      (hash-ref (globals) x
        (lambda () #f)))))

; Returns the original (first-created) box
(define (->orig-box x)
  (hash-ref! (orig-globals) x
    (lambda ()
      (->global-box! x))))

(define (orig-box? x y)
  (when (symbol? x)
    (set! x (->safe-box x)))
  (if (box? x)
      (eq? (->orig-box y) x)
      #f))

(define (global? x)
  (and (symbol? x)
       (not (hash-has-key? (locals) x))))

(define (lookup x yes no)
  (when (and (global? x)
             (hash-has-key? (globals) x))
    (set! x (hash-ref (globals) x)))
  (if (box? x)
      (let* ((u (gensym))
             (x (namespace-variable-value
                  (box-uniq x)
                  #f
                  (lambda () u))))
        (if (eq? x u)
            (no)
            (yes x)))
      (no)))

(define (set-raw n v)
  (namespace-set-variable-value!
    (box-uniq (->global-box! n))
    v
    #f))

(define (set-name n v)
  (set-raw n (nameit n v)))

(define (set-sig n s v)
  ; TODO: this uses symbols rather than boxes
  (hash-set! sig n s)
  (set-name n v))

(define (w/-maker body f)
  (let* ((old  (globals))
         (body (ac-all body))
         (new  (globals)))
    (globals (f old new))
    (cons nocompile
      `(begin ,@body))))

(define (w/exclude old new x)
  (if (hash-has-key? old x)
      (hash-set new x (hash-ref old x))
      (hash-remove new x)))

;=============================================================================
;  ssyntax
;=============================================================================
; Though graphically the right choice, can't use _ for currying
; because then _!foo becomes a function.  Maybe use <>.  For now
; leave this off and see how often it would have been useful.

; Might want to make ~ have less precedence than &, because
; ~foo&bar prob should mean (andf (complement foo) bar), not
; (complement (andf foo bar)).
(define (symbol->chars x) (string->list (symbol->string x)))

;; TODO: why does this count backwards...? efficiency, maybe?
(define (has-ssyntax-char? string i)
  (and (>= i 0)
       (or (let ((c (string-ref string i)))
             (or (eqv? c #\:) (eqv? c #\~)
                 (eqv? c #\&)
                 ;(eqv? c #\_)
                 (eqv? c #\.)  (eqv? c #\!)))
           (has-ssyntax-char? string (- i 1)))))

(define (tokens test source token acc keepsep?)
  (cond ((null? source)
          (reverse (if (pair? token)
                       (cons (reverse token) acc)
                       acc)))
        ((test (car source))
          (tokens test
                  (cdr source)
                  null
                  (let ((rec (if (null? token)
                                 acc
                                 (cons (reverse token) acc))))
                    (if keepsep?
                        (cons (car source) rec)
                        rec))
                  keepsep?))
        (else
          (tokens test
                  (cdr source)
                  (cons (car source) token)
                  acc
                  keepsep?))))

(define (ssyntax? x)
  (and (symbol? x)
       ;(not (or (eq? x '+) (eq? x '++) (eq? x '_)))
       (let ((name (symbol->string x)))
         (has-ssyntax-char? name (- (string-length name) 1)))))

(define (chars->value chars) (read-from-string (list->string chars)))
(define (insym? char sym) (member char (symbol->chars sym)))

(define (expand-compose sym)
  (let ((elts (map (lambda (tok)
                     (if (eqv? (car tok) #\~)
                         (if (null? (cdr tok))
                             (->orig-box 'no)
                             (list (->orig-box 'complement) (chars->value (cdr tok))))
                         (chars->value tok)))
                   (tokens (lambda (c) (eqv? c #\:))
                           (symbol->chars sym)
                           null
                           null
                           #f))))
    (if (null? (cdr elts))
        (car elts)
        (cons (->orig-box 'compose) elts))))

(define (build-sexpr toks orig)
  (cond ((null? toks)
          (->orig-box 'get))
        ((null? (cdr toks))
          (chars->value (car toks)))
        (else
          (list (build-sexpr (cddr toks) orig)
                (if (eqv? (cadr toks) #\!)
                    (list (->orig-box 'quote) (chars->value (car toks)))
                    (if (or (eqv? (car toks) #\.) (eqv? (car toks) #\!))
                        (error "bad ssyntax" orig)
                        (chars->value (car toks))))))))

(define (expand-and sym)
  (let ((elts (map chars->value
                   (tokens (lambda (c) (eqv? c #\&))
                           (symbol->chars sym)
                           null
                           null
                           #f))))
    (if (null? (cdr elts))
        (car elts)
        (cons (->orig-box 'andf) elts))))

(define (expand-sexpr sym)
  (build-sexpr (reverse (tokens (lambda (c) (or (eqv? c #\.) (eqv? c #\!)))
                                (symbol->chars sym)
                                null
                                null
                                #t))
               sym))

;; TODO: better definition of ssexpand
(define (ssexpand sym)
  (cond ((or (insym? #\: sym) (insym? #\~ sym))  (expand-compose sym))
        ((or (insym? #\. sym) (insym? #\! sym))  (expand-sexpr sym))
        ((insym? #\& sym)                        (expand-and sym))
        (else                                    (error "unknown ssyntax" sym))))

(define (init)
  (->orig-box 'fn)
  (->orig-box 'and)
  (->orig-box 'compose)
  (->orig-box 'complement)
  (->orig-box 'no)
  (->orig-box 'andf)
  (->orig-box 'string)
  (->orig-box 'quote)
  (->orig-box 'unquote)
  (->orig-box 'unquote-splicing)
  (->orig-box 'quasiquote)
  (->orig-box 'get))
